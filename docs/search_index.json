[
["index.html", "R语言模型部署实战 序言", " R语言模型部署实战 徐静 2018-12-31 序言 我们的模型不能只停留在线下的分析报告中，训练好的R模型如何应用到生产环境？目前针对于R语言的模型生产环境应用的方式有很多，比如用其他语言去调用，Java，Python等语言均可方便的调用R脚本；生成PMML文件，目前R中主流的一些R模型均支持PMML比如xgboost,lightGBM等，其他语言不需要调用R脚本只需调用统一的PMML文件就可以；还有就是Web端的部署，比如可以做成REST API供其他语言调用，或直接做成web应用供其他用户访问，本书主要针对于R语言模型的Web端的部署。过程中，我们会先后介绍httpuv,opencpu,plumber, jug,fiery,Rserve,RestRserve,等一些和模型线上化部署相关的R包(当然shiny也可以，但他不是我们本书的重点)，最后会介绍mailR和Rweixin两个R和邮件与微信通信的R包，用于线上化部署的监测。当然会有其他的线上化部署方式。 欢迎进入R模型线上化部署的海洋！ "],
["e585b3e4ba8ee68891.html", "关于我", " 关于我 徐静： 硕士研究生, 目前的研究兴趣主要包括：数理统计，统计机器学习，深度学习，网络爬虫，前端可视化，R语言和Python语言的超级粉丝，多个R包和Python模块的作者，现在正逐步向Java迁移。 Graduate students,the current research interests include: mathematical statistics, statistical machine learning, deep learning, web crawler, front-end visualization. He is a super fan of R and Python, and the author of several R packages and Python modules, and now gradually migrating to Java. "],
["httpuv.html", "第 1 章 httpuv 1.1 方法介绍 1.2 例子演示", " 第 1 章 httpuv 在httpuv的官网中,有这么一段描述： Allows R code to listen for and interact with HTTP and WebSocket clients, so you can serve web traffic directly out of your R process. Implementation is based on libuv and http-parser. This is a low-level library that provides little more than network I/O and implementations of the HTTP and WebSocket protocols. For an easy way to create web applications, try Shiny instead. 我们可以通过httpuv搭建一个访问R模型的web API,但可能这不是最好的。 本部分我们首先介绍官方提供的一些方法，然后解析官方提供的演示Demo,从而达到熟练使用httpuv的目的。 1.1 方法介绍 下面我们解析一下httpuv官方提供的一些调用方法，并演示一些调用方法对应的实例 1.使用URI编码/解码以与Web浏览器相同的方式对字符串进行编码/解码。 encodeURI(value) encodeURIComponent(value) decodeURI(value) decodeURIComponent(value) 参数列表 value 用于编码和解码的字符向量，UTF-8字符编码 library(httpuv) value &lt;- &quot;https://baidu.com/中国;?/&quot; encodeURI(value) ## [1] &quot;https://baidu.com/%D6%D0%B9%FA;?/&quot; encodeURIComponent(value) ## [1] &quot;https%3A%2F%2Fbaidu.com%2F%D6%D0%B9%FA%3B%3F%2F&quot; decodeURI(value) ## [1] &quot;https://baidu.com/中国;?/&quot; decodeURIComponent(value) ## [1] &quot;https://baidu.com/中国;?/&quot; 注意： encodeURI 与 encodeURIComponent是不一样的因为前者不对特殊字符: ;,/?:@&amp;=+$等进行encode 2.中断httpuv运行的环路 interrupt() 检查ip地址的类型是ipv4还是ipv6 ipFamily(ip) 参数列表 ip 一个代表IP地址的字符串 返回值的意义：如果是IPv4返回4，如果是IPv6返回6，如果不是IP地址返回-1 ipFamily(&quot;127.0.0.1&quot;) # 4 ## [1] 4 ipFamily(&quot;500.0.0.500&quot;) # -1 ## [1] -1 ipFamily(&quot;500.0.0.500&quot;) # -1 ## [1] -1 ipFamily(&quot;::&quot;) # 6 ## [1] 6 ipFamily(&quot;::1&quot;) # 6 ## [1] 6 ipFamily(&quot;fe80::1ff:fe23:4567:890a&quot;) # 6 ## [1] 6 3.将原始向量转换为BASE64编码字符串 rawToBase64(x) 参数列表 x 原始向量 set.seed(100) result &lt;- rawToBase64(as.raw(runif(19, min=0, max=256))) #stopifnot(identical(result, &quot;TkGNDnd7z16LK5/hR2bDqzRbXA==&quot;)) result ## [1] &quot;TkGNDnd7z16LK5/hR2bDqzRbXA==&quot; 4.运行一个server runServer(host, port, app, interruptIntervalMs = NULL) 参数列表 host IPv4地址, 或是“0.0.0.0”监听所有的IP port 端口号 app 一个定义应用的函数集合 interruptIntervalMs 该参数不提倡使用，1.3.5版本后废除 app &lt;- list(call = function(req){ list(status=200L, headers = list( &#39;Content-Type&#39; = &#39;text/html&#39; ), body = &quot;HelloWorld!&quot;) }) runServer(&quot;0.0.0.0&quot;, 5000,app) 5.过程请求 处理HTTP请求和WebSocket消息。 如果R的调用堆栈上没有任何东西，如果R是 在命令提示符下闲置，不必调用此函数，因为请求将 自动处理。但是，如果R正在执行代码，则请求将不被处理。 要么调用栈是空的，要么调用这个函数(或者，调用run_now())。 service(timeoutMs = ifelse(interactive(), 100, 1000)) 参数列表 timeoutMs 返回之前运行的毫秒数。 6.创建HTTP/WebSocket后台服务器（弃用） startDaemonizedServer(host, port, app) 7.创建HTTP/WebSocket服务器 startServer(host, port, app) startPipeServer(name, mask, app) 参数列表 host ip地址 port 端口号 app 一个定义应用的函数集 app &lt;- list( call = function(req) { list( status = 200L, headers = list( &#39;Content-Type&#39; = &#39;text/html&#39; ), body = &quot;Hello world!&quot; ) } ) handle &lt;- startServer(&quot;0.0.0.0&quot;, 5000,app) # 此服务器的句柄，可以传递给StestServer以关闭服务器。 stopServer(handle) 8.停止所有应用 stopAllServers() 9.在UNIX环境中停止运行的后台服务器（弃用） stopDaemonizedServer(handle) 10.停止一个服务 stopServer(handle) 1.2 例子演示 json-server # Connect to this using websockets on port 9454 # Client sends to server in the format of {&quot;data&quot;:[1,2,3]} # The websocket server returns the standard deviation of the sent array library(jsonlite) library(httpuv) # Server app &lt;- list( onWSOpen = function(ws) { ws$onMessage(function(binary, message) { # Decodes message from client message &lt;- fromJSON(message) # Sends message to client ws$send( # JSON encode the message toJSON( # Returns standard deviation for message sd(message$data) ) ) }) } ) runServer(&quot;0.0.0.0&quot;, 9454, app, 250) 2.echo library(httpuv) app &lt;- list( call = function(req) { wsUrl = paste(sep=&#39;&#39;, &#39;&quot;&#39;, &quot;ws://&quot;, ifelse(is.null(req$HTTP_HOST), req$SERVER_NAME, req$HTTP_HOST), &#39;&quot;&#39;) list( status = 200L, headers = list( &#39;Content-Type&#39; = &#39;text/html&#39; ), body = paste( sep = &quot;\\r\\n&quot;, &quot;&lt;!DOCTYPE html&gt;&quot;, &quot;&lt;html&gt;&quot;, &quot;&lt;head&gt;&quot;, &#39;&lt;style type=&quot;text/css&quot;&gt;&#39;, &#39;body { font-family: Helvetica; }&#39;, &#39;pre { margin: 0 }&#39;, &#39;&lt;/style&gt;&#39;, &quot;&lt;script&gt;&quot;, sprintf(&quot;var ws = new WebSocket(%s);&quot;, wsUrl), &quot;ws.onmessage = function(msg) {&quot;, &#39; var msgDiv = document.createElement(&quot;pre&quot;);&#39;, &#39; msgDiv.innerHTML = msg.data.replace(/&amp;/g, &quot;&amp;amp;&quot;).replace(/\\\\&lt;/g, &quot;&amp;lt;&quot;);&#39;, &#39; document.getElementById(&quot;output&quot;).appendChild(msgDiv);&#39;, &quot;}&quot;, &quot;function sendInput() {&quot;, &quot; var input = document.getElementById(&#39;input&#39;);&quot;, &quot; ws.send(input.value);&quot;, &quot; input.value = &#39;&#39;;&quot;, &quot;}&quot;, &quot;&lt;/script&gt;&quot;, &quot;&lt;/head&gt;&quot;, &quot;&lt;body&gt;&quot;, &#39;&lt;h3&gt;Send Message&lt;/h3&gt;&#39;, &#39;&lt;form action=&quot;&quot; onsubmit=&quot;sendInput(); return false&quot;&gt;&#39;, &#39;&lt;input type=&quot;text&quot; id=&quot;input&quot;/&gt;&#39;, &#39;&lt;h3&gt;Received&lt;/h3&gt;&#39;, &#39;&lt;div id=&quot;output&quot;/&gt;&#39;, &#39;&lt;/form&gt;&#39;, &quot;&lt;/body&gt;&quot;, &quot;&lt;/html&gt;&quot; ) ) }, onWSOpen = function(ws) { ws$onMessage(function(binary, message) { ws$send(message) }) } ) browseURL(&quot;http://localhost:9454/&quot;) runServer(&quot;0.0.0.0&quot;, 9454, app, 250) 3.deamon-echo library(httpuv) .lastMessage &lt;- NULL app &lt;- list( call = function(req) { wsUrl = paste(sep=&#39;&#39;, &#39;&quot;&#39;, &quot;ws://&quot;, ifelse(is.null(req$HTTP_HOST), req$SERVER_NAME, req$HTTP_HOST), &#39;&quot;&#39;) list( status = 200L, headers = list( &#39;Content-Type&#39; = &#39;text/html&#39; ), body = paste( sep = &quot;\\r\\n&quot;, &quot;&lt;!DOCTYPE html&gt;&quot;, &quot;&lt;html&gt;&quot;, &quot;&lt;head&gt;&quot;, &#39;&lt;style type=&quot;text/css&quot;&gt;&#39;, &#39;body { font-family: Helvetica; }&#39;, &#39;pre { margin: 0 }&#39;, &#39;&lt;/style&gt;&#39;, &quot;&lt;script&gt;&quot;, sprintf(&quot;var ws = new WebSocket(%s);&quot;, wsUrl), &quot;ws.onmessage = function(msg) {&quot;, &#39; var msgDiv = document.createElement(&quot;pre&quot;);&#39;, &#39; msgDiv.innerHTML = msg.data.replace(/&amp;/g, &quot;&amp;amp;&quot;).replace(/\\\\&lt;/g, &quot;&amp;lt;&quot;);&#39;, &#39; document.getElementById(&quot;output&quot;).appendChild(msgDiv);&#39;, &quot;}&quot;, &quot;function sendInput() {&quot;, &quot; var input = document.getElementById(&#39;input&#39;);&quot;, &quot; ws.send(input.value);&quot;, &quot; input.value = &#39;&#39;;&quot;, &quot;}&quot;, &quot;&lt;/script&gt;&quot;, &quot;&lt;/head&gt;&quot;, &quot;&lt;body&gt;&quot;, &#39;&lt;h3&gt;Send Message&lt;/h3&gt;&#39;, &#39;&lt;form action=&quot;&quot; onsubmit=&quot;sendInput(); return false&quot;&gt;&#39;, &#39;&lt;input type=&quot;text&quot; id=&quot;input&quot;/&gt;&#39;, &#39;&lt;h3&gt;Received&lt;/h3&gt;&#39;, &#39;&lt;div id=&quot;output&quot;/&gt;&#39;, &#39;&lt;/form&gt;&#39;, &quot;&lt;/body&gt;&quot;, &quot;&lt;/html&gt;&quot; ) ) }, onWSOpen = function(ws) { ws$onMessage(function(binary, message) { .lastMessage &lt;&lt;- message ws$send(message) }) } ) server &lt;- startDaemonizedServer(&quot;0.0.0.0&quot;, 9454, app) # check the value of .lastMessage after echoing to check it is being updated # call this after done #stopDaemonizedServer(server) library(httpuv) app = list(call = function(req){ # 获取POST的参数 postdata = req$rook.input$read_lines() qs = httr:::parse_query(gsub(&quot;^\\\\?&quot;, &quot;&quot;, postdata)) dat = jsonlite::fromJSON(qs$jsonDat) print(dat) # 计算返回结果 r = 0.3 + 0.1 * dat$v1 - 0.2 * dat$v2 + 0.1 * dat$v3 output = jsonlite::toJSON(list(message = &#39;suceess&#39;, result = r), auto_unbox = T) res = list(status = 200L, headers = list(&#39;Content-Type&#39; = &#39;application/json&#39;), body = output) return(res) }) # 启动服务 server = startServer(&quot;0.0.0.0&quot;, 1124L, app = app) while(TRUE) { service() Sys.sleep(0.001) } # stopServer(server) RCurl::postForm(&#39;127.0.0.1:1124&#39;, style = &#39;post&#39;, .params = list(jsonDat = &#39;{&quot;v1&quot;:1,&quot;v2&quot;:2,&quot;v3&quot;:3}&#39;) ) httpuv是相对比较底层的包，熟练使用需要掌握前端知识，并且需要用到RCurl，httr相关爬虫包的一些知识去处理。本人不推荐这种方式进行模型的部署。 "],
["opencpu.html", "第 2 章 opencpu 2.1 安装 2.2 API文档 2.3 XGBoost模型部署实例", " 第 2 章 opencpu 2.1 安装 关于opencpu-server的安装和本地单用户服务器的安装可以参考 https://www.opencpu.org/download.html, opencpu官方推荐在Ubuntu 18.04 / 16.04中使用opencpu-server, 关于Fedora,Debian,CentOS等系统的安装可以参考https://github.com/opencpu 2.1.1 Ubuntu 18.04/16.04 安装 # Requires Ubuntu 18.04 (Bionic) or 16.04 (Xenial) sudo add-apt-repository -y ppa:opencpu/opencpu-2.1 sudo apt-get update sudo apt-get upgrade # Installs OpenCPU server sudo apt-get install -y opencpu-server # Done! Open http://yourhost/ocpu in your browser # rstudio server的安装(不是必须的) sudo apt-get install -y rstudio-server # 安装完之后，需要检查自己R中的curl包及stringi等包的版本， # 同时如果需要R markdown还需要安装pandoc sudo apt-get install pandoc 2.1.2 本地单用户服务器 # Install OpenCPU install.packages(&quot;opencpu&quot;) # Run Apps directly from Github library(opencpu) ocpu_start_app(&quot;rwebapps/nabel&quot;) ocpu_start_app(&quot;rwebapps/markdownapp&quot;) ocpu_start_app(&quot;rwebapps/stockapp&quot;) # Run Apps directly from library library(opencpu) ocpu_start_server() # Install / remove apps remove_apps(&quot;rwebapps/stockapp&quot;) 2.2 API文档 /* .panel-primary { border-color: #428bca; }*/ .panel { margin-bottom: 20px; background-color: #fff; border: 1px solid transparent; border-radius: 4px; -webkit-box-shadow: 0 1px 1px rgba(0,0,0,0.05); box-shadow: 0 1px 1px rgba(0,0,0,0.05); border-color: #428bca; } .panel-heading { padding: 5px 15px; border-bottom: 1px solid #357ae8; border-top-right-radius: 3px; border-top-left-radius: 3px; background-color:#357ae8 } .panel-body { padding: 15px; } 2.2.1 OpenCPU中的HTTP OpenCPU根路径 API的root是动态的。默认为/ocpu/，可以更改此设置。通过R启动的本地服务，可以通过ocpu_start_server(port = 5656, root = &quot;/ocpu&quot;, workers = 2,preload = NULL, on_startup = NULL, no_cache = FALSE)中的rootc参数修改，opencpu-server可以通过修改/usr/lib/opencpu/rapache中的文件进行修改。在下面的示例中，我们假设默认值/ocpu/。 Debug http://172.16.100.202/ocpu/info opencpu的一些详细的信息 该http://172.16.100.202/ocpu/test URL为您提供了一个方便的测试网页来执行服务器请求 Http的方法 OpenCPU目前只使用HTTP方法GET和POST。GET用于检索资源，POST用于RPC。POST请求仅对脚本或功能URL有效。 # Get 举栗 curl http://172.16.100.202/ocpu/library/MASS/data/Boston/json curl http://172.16.100.202/ocpu/library/MASS/NEWS curl http://172.16.100.202/ocpu/library/MASS/scripts/ #Post 举栗 -X POST or -d &quot;arg=value&quot; curl http://172.16.100.202/ocpu/library/MASS/scripts/ch01.R -X POST curl http://172.16.100.202/ocpu/library/stats/R/rnorm -d &quot;n=10&amp;mean=5&quot; Http状态码 这些是OpenCPU返回的常见状态代码，客户端应该能够解释这些状态代码 2.2.2 API 端点(EndPoints) The API Libraries #read packages 举栗 curl http://172.16.100.202/ocpu/library/ curl http://172.16.100.202/ocpu/apps/rwebapps/ curl http://172.16.100.202/ocpu/user/jeroen/library/ #read session 举栗 curl http://172.16.100.202/ocpu/tmp/x2c5ab8d4d6 The R package API /{package}/库都支持以下端点： #package info curl http://172.16.100.202/ocpu/library/MASS/ #package objects (mostly functions) curl http://172.16.100.202/ocpu/library/MASS/R/ curl http://172.16.100.202/ocpu/library/MASS/R/rlm/print #package data objects curl http://172.16.100.202/ocpu/library/MASS/data/ curl http://172.16.100.202/ocpu/library/MASS/data/housing/json #read manuals pages curl http://172.16.100.202/ocpu/library/MASS/man/ curl http://172.16.100.202/ocpu/library/MASS/man/rlm/text curl http://172.16.100.202/ocpu/library/MASS/man/rlm/html curl http://172.16.100.202/ocpu/library/MASS/man/rlm/pdf #read files included with this package curl http://172.16.100.202/ocpu/library/MASS/scripts/ curl http://172.16.100.202/ocpu/library/MASS/scripts/ch01.R curl http://172.16.100.202/ocpu/library/MASS/NEWS #call a function (example from &#39;rlm&#39; help page) curl http://172.16.100.202/ocpu/library/MASS/R/rlm -d &quot;formula=stack.loss ~ .&amp;data=stackloss&amp;psi=psi.bisquare&quot; #run R script curl http://172.16.100.202/ocpu/library/MASS/scripts/ch01.R -X POST #read output (replace key with value returned from previous request) curl http://172.16.100.202/ocpu/tmp/x0648ec526b/R/.val/print The R object API /R API 用来读取R对象或者调用R的方法. #list objects and datasets from MASS curl http://172.16.100.202/ocpu/library/MASS/R/ curl http://172.16.100.202/ocpu/library/MASS/data/ #retrieve objects curl http://172.16.100.202/ocpu/library/MASS/R/truehist/print curl http://172.16.100.202/ocpu/library/MASS/data/bacteria/print curl http://172.16.100.202/ocpu/library/MASS/data/bacteria/json curl http://172.16.100.202/ocpu/library/MASS/data/bacteria/csv curl http://172.16.100.202/ocpu/library/MASS/data/bacteria/rda #call a function curl http://172.16.100.202/ocpu/library/MASS/R/truehist -d &quot;data=[1,3,7,4,2,4,2,6,23,13,5,2]&quot; The R session API 会话(session)是一个容器，用于保存从远程函数/脚本调用（RPC）创建的资源。 #A POST will create a temporary session #Use the returned key for the subsequent calls below curl http://172.16.100.202/ocpu/library/MASS/scripts/ch01.R -X POST #Look at console input/output curl http://172.16.100.202/ocpu/tmp/x05b85461/console/text #We read session R objects curl http://172.16.100.202/ocpu/tmp/x05b85461/ curl http://172.16.100.202/ocpu/tmp/x05b85461/R/ curl http://172.16.100.202/ocpu/tmp/x05b85461/R/dd/csv curl http://172.16.100.202/ocpu/tmp/x05b85461/R/t.stat/print #Or even call a function curl http://172.16.100.202/ocpu/tmp/x05b85461/R/t.stat -d &quot;x=[1,0,0,1,1,1,0,1,1,0]&quot; #Download file from the working dir curl http://172.16.100.202/ocpu/tmp/x05b85461/files/ch01.pdf #Check sessionInfo curl http://172.16.100.202/ocpu/tmp/x05b85461/info/print 2.2.3 输入，输出：数据和格式 R对象的输出格式 可以以各种输出格式检索任何R对象（包括记录的图形） #read R objects from packages. curl http://172.16.100.202/ocpu/library/datasets/R/mtcars/json?digits=0 curl http://172.16.100.202/ocpu/library/datasets/R/mtcars/csv curl http://172.16.100.202/ocpu/library/datasets/R/mtcars/tab?sep=&quot;|&quot; curl http://172.16.100.202/ocpu/library/MASS/R/loglm/print #create a simple plot curl http://172.16.100.202/ocpu/library/graphics/R/plot -d &quot;x=cars&quot; #replace session id with returned one curl http://172.16.100.202/ocpu/tmp/x0468b7ab/graphics/last/png curl http://172.16.100.202/ocpu/tmp/x0468b7ab/graphics/1/png?width=1000 curl http://172.16.100.202/ocpu/tmp/x0468b7ab/graphics/last/svg curl http://172.16.100.202/ocpu/tmp/x0468b7ab/graphics/last/pdf?width=8 R函数调用的参数格式（仅限HTTP POST） 调用函数时，我们需要传递参数。OpenCPU接受以下类型的参数 执行函数功能时, Post的数据 (请求体) 可以使下面面的任意形式：multipart/form-data, application/x-www-form-urlencoded, application/json 或者 application/x-protobuf. 并非每个content-type都支持任何参数格式: #call some functions curl http://172.16.100.202/ocpu/library/stats/R/rnorm -d &quot;n=10&amp;mean=5&quot; curl http://172.16.100.202/ocpu/library/graphics/R/hist -d &quot;x=[2,3,2,3,4,3,3]&amp;breaks=10&quot; curl http://172.16.100.202/ocpu/library/graphics/R/plot -d &quot;x=cars&amp;main=&#39;test&#39;&quot; curl http://172.16.100.202/ocpu/library/base/R/identity -d &quot;x=coef(lm(speed~dist, data=cars))&quot; #upload local file mydata.csv curl http://172.16.100.202/ocpu/library/utils/R/read.csv -F &quot;file=@mydata.csv&quot; #replace session id with returned one above curl http://172.16.100.202/ocpu/tmp/x067b4172/R/.val/print curl http://172.16.100.202/ocpu/library/base/R/summary -d &quot;object=x067b4172&quot; #post arguments in json curl http://cloud.opencpu.org/ocpu/library/stats/R/rnorm \\ -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;n&quot;:10, &quot;mean&quot;: 10, &quot;sd&quot;:10}&#39; 运行脚本和可重现的文档 我们可以通过对文件执行HTTP POST来运行脚本。该脚本根据其（不区分大小写）文件扩展名进行解释。任何HTTP POST参数都会传递给解释函数。支持以下类型： #run scripts which exist in packages curl http://172.16.100.202/ocpu/library/MASS/scripts/ch01.R -X POST curl http://172.16.100.202/ocpu/library/brew/featurefull.brew -X POST curl http://172.16.100.202/ocpu/library/brew/brew-test-2.brew -d &quot;output=output.html&quot; curl http://172.16.100.202/ocpu/library/knitr/examples/knitr-minimal.Rmd -X POST curl http://172.16.100.202/ocpu/library/knitr/examples/knitr-minimal.Rmd -d &quot;format=docx&quot; curl http://172.16.100.202/ocpu/library/knitr/examples/knitr-minimal.Rmd -d &quot;format=html&quot; curl http://172.16.100.202/ocpu/library/knitr/examples/knitr-minimal.Rnw JSON I / O RPC（又名数据处理单元） 对于客户端只对JSON格式的函数调用的输出数据感兴趣的常见特殊情况，可以使用后置修复HTTP POST请求URL /json。在这种情况下，成功调用将返回状态200（而不是201），并且响应主体直接包含JSON中返回的对象; 无需额外的GET请求。 curl http://cloud.opencpu.org/ocpu/library/stats/R/rnorm/json -d n=2 [ -1.2804, -0.75013 ] 我们可以将它与application/jsonR函数上的完整JSON RPC 的请求内容类型相结合 curl http://cloud.opencpu.org/ocpu/library/stats/R/rnorm/json \\ -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;n&quot;:3, &quot;mean&quot;: 10, &quot;sd&quot;:10}&#39; [ 4.9829, 6.3104, 11.411 ] 上面的请求调用以下R函数调用: library(jsonlite) args &lt;- fromJSON(&#39;{&quot;n&quot;:3, &quot;mean&quot;: 10, &quot;sd&quot;:10}&#39;) output &lt;- do.call(stats::rnorm, args) toJSON(output) 在这种情况下，相当于： rnorm(n=3, mean=10, sd=10) 2.2.4 其他功能 OpenCPU应用程序 OpenCPU应用程序是包含在R包中的静态网页（html，css，js）。它们通过OpenCPU API连接此包中的R函数。按照惯例，这些应用程序放在/inst/www/R源包的目录中。有关应用页面的更多信息，请参阅。 rnorm(n=3, mean=10, sd=10) Github CI Hook OpenCPU云服务器包括对持续集成（CI）的支持。因此，每次将提交推送到主分支时，可以将Github存储库配置为在OpenCPU服务器上自动安装程序包。要利用此功能，需要： R源包位于存储库的根目录中。（例） Github用户帐户有一个公共电子邮件地址 要设置CI，/ocpu/webhook请在Github存储库中将服务器的URL 添加为“WebHook”。例如，要使用公共演示服务器，请添加带有以下URL的webhook（您可以保持Content-type和Secret字段不变） https://cloud.opencpu.org/ocpu/webhook 要触发build，请将提交推送到主分支。build将显示在您的github webhook页面中的Recent Deliveries下，如果安装成功，您应该收到一封电子邮件（在您的垃圾邮件文件夹中）。如果是，则该程序包将直接可用于/ocpu/apps/{username}/{package}/服务器上的远程使用。 如果您使用的是公共服务器，则该程序包也可以通过https://{yourname}.ocpu.io/{package}/。如果您正在运行自己的OpenCPU云服务器，则必须配置SMTP服务器才能使电子邮件通知正常工作。 2.3 XGBoost模型部署实例 本节将基于垃圾邮件的分类任务，训练一个XGBoost模型，基于训练的XGBoost模型构建一个R包，该R包的功能用于预测一封邮件是垃圾邮件的概率，并构建一个前端的页面，测试前端页面在opencpu中是可用的。其步骤如下: 2.3.1 训练模型 library(xgboost) library(ElemStatLearn) # 用于构建R包使用 data &lt;- save(spam,file=&#39;mail_data.rda&#39;) x = as.matrix(spam[, -ncol(spam)]) y = as.numeric(spam$spam) - 1 xgbmodel = xgboost(data = x, label = y, nrounds = 5, objective = &#39;binary:logistic&#39;) # 这里模型保存的路径可以自己设置 # 保存的训练模型用于构建R包 save(xgbmodel, file=&quot;xgb.rda&quot;) xgb_model &lt;- load(&quot;xgb.rda&quot;) xgbmodel data_spam &lt;- as.matrix(spam[1, -ncol(spam)]) pred &lt;- predict(xgbmodel,data_spam) # pred &lt;- xgboost:::predict.xgb.Booster(object = xgbmodel, newdata = data_spam) 2.3.2 构建R包 关于R包的构建，本教程不做详细的介绍，如果个人感兴趣可以参考R官网中的教程或Hadley Wickham的《R packages》 #&#39; @title Mail predict test for opencpu #&#39; @description Mail predict test for opencpu. #&#39; @name mailPred #&#39; @aliases mailPred #&#39; @author Xu Jing #&#39; @usage mailPreds(id) #&#39; @param id The row of mial data #&#39; #&#39; @import xgboost #&#39; @import jsonlite #&#39; @import stats #&#39; @import utils #&#39; #&#39; @export mailPreds mailPreds &lt;- function(id = &#39;1&#39;) { message(&quot;XGBoost model test on opencpu!&quot;) spam &lt;- NULL xgbmodel &lt;- NULL spam_path &lt;- system.file(&quot;extdata&quot;, &quot;mail_data.rda&quot;, package = &quot;mailPred&quot;) xgbmodel_path &lt;- system.file(&quot;extdata&quot;, &quot;xgb.rda&quot;, package = &quot;mailPred&quot;) data_spam &lt;- load(spam_path) model_xgb &lt;- load(xgbmodel_path) x = as.matrix(spam[as.integer(id), -ncol(spam)]) # y = as.numeric(spam[as.integer(id), ncol(spam)]) - 1 pred &lt;- predict(xgbmodel,x) # print(spam) return(list(class = pred,id=id)) } # DESCRIPTION Package: mailPred Type: Package Title: XGBoost Predict Mail Version: 0.1.0 Author: XuJing Maintainer: XuJing &lt;274762204@qq.com&gt; Description: Mail predict test for opencpu. License: GPL (&gt;= 2) Encoding: UTF-8 LazyData: false Date: 2018-12-30 URL: https://github.com/DataXujing/mailPred BugReports: https://github.com/DataXujing/mailPred/issues RoxygenNote: 6.1.1 Depends: R (&gt;= 3.4.0) Imports: xgboost,jsonlite,stats,utils Suggests: rmarkdown, knitr VignetteBuilder: knitr 2.3.3 编译R包并安装 Rstudio中离线安装 Ubuntu中离线安装 R CMD INSTALL mailPred_0.1.0.tar.gz 2.3.4 opencpu的一些配置 修改opencup服务参数，文件位于 /etc/opencpu/server.conf，增加预加载的包 &quot;preload&quot;: [&quot;jsonlite&quot;,&quot;xgboost&quot;,&quot;glmnet&quot;,&quot;mailPred&quot;,&quot;ocputest&quot;] 2.3.5 本地opencpu服务测试 library(opencpu) ocpu_start_server(root=&#39;xj&#39;) http://localhost:5656/xj/test/ http://localhost:5656/xj/library/mailPred/info http://localhost:5656/xj/library/mailPred/www/mailpred.html 2.3.6 Ubuntu 16.04 opencpu-server部署测试 2.3.7 Github部署测试 详细的参考Github CI Hook部分及https://github.com/DataXujing/mailPred 2.3.8 官方例子 官方提供了更多的例子，详细的可以参考https://www.opencpu.org/apps.html "],
["plumber.html", "第 3 章 plumber 3.1 快速开始 3.2 路由和输入 3.3 Rendering Output 3.4 部署 3.5 其他", " 第 3 章 plumber HTTP API已成为软件通信的主要语言。通过创建HTTP API，您将使您的R代码能够被其他服务利用 - 无论它们是在您的组织内部还是托管在世界的另一端。以下是在您将R代码包装在Plumber API中时向您打开的门的一些想法： 在您的组织中使用其他语言编写的软件可以运行您的R代码。您公司的Java应用程序现在可以引入您按需生成的自定义ggplot2图表，或者Python客户端可以查询R中定义的预测模型。 您可以代表您使用某些第三方接收电子邮件，然后在新邮件到达时通知您的Plumber服务。 您可以在Slack上注册一个“ Slash Command ”，使您能够执行R功能以响应Slack中输入的命令。 您可以编写从访问者的Web浏览器查询Plumber API的JavaScript代码。更进一步，您可以将Plumber专门用作交互式Web应用程序的后端。 Plumber托管在CRAN上，因此您可以通过运行以下命令下载并安装最新的稳定版本及其所有依赖项： install.paclages(&quot;plumber&quot;) 或者，如果您想运行最新的不稳定开发版本plumber，可以使用该软件包从其GitHub存储库安装它devtools。 install.packages(&quot;devtools&quot;) devtools::install_github(&quot;trestletech/plumber&quot;) 3.1 快速开始 Plumber允许您通过仅使用特殊注释装饰现有R代码来创建API(#*或#’)。下面的示例显示了一个名为plumber.R（Plumber API的常规名称）的文件，该文件定义了API。 # plumber.R #&#39; Echo the parameter that was sent in #&#39; @param msg The message to echo back. #&#39; @get /echo function(msg=&quot;&quot;){ list(msg = paste0(&quot;The message is: &#39;&quot;, msg, &quot;&#39;&quot;)) } #&#39; Plot out data from the iris dataset #&#39; @param spec If provided, filter the data to only this species (e.g. &#39;setosa&#39;) #&#39; @get /plot #&#39; @png function(spec){ myData &lt;- iris title &lt;- &quot;All Species&quot; # Filter if the species was specified if (!missing(spec)){ title &lt;- paste0(&quot;Only the &#39;&quot;, spec, &quot;&#39; Species&quot;) myData &lt;- subset(iris, Species == spec) } plot(myData$Sepal.Length, myData$Petal.Length, main=title, xlab=&quot;Sepal Length&quot;, ylab=&quot;Petal Length&quot;) } 此文件定义了两个Plumber“端点”。一个托管在路径上/echo，只是回显传入的消息; 另一个托管在路径上/plot并返回一个显示简单R图的图像。 你可以使用plumber::plumb函数来此R档转换成管道工API： pr &lt;- plumber::plumb(&quot;plumber.R&quot;) 该pr对象现在封装了plumber.R文件中表示的所有逻辑。下一步是使用以下run方法使API生效： pr$run() 不妨运行试一下！！！ 在前面的示例中，您看到了一个呈现为JSON的端点和一个生成图像的端点。除非另有说明，否则Plumber将尝试呈现您的端点函数返回的任何内容作为JSON。但是，您可以指定备用“序列化程序”，指示Plumber将输出呈现为其他格式，如HTML（@html），PNG（@png）或JPEG（@jpeg） #&#39; @get /hello #&#39; @html function(){ &quot;&lt;html&gt;&lt;h1&gt;hello world&lt;/h1&gt;&lt;/html&gt;&quot; } 访问时，此端点将生成类似以下内容的内容。它还设置了适当的Content-Type标题，以便访问此页面的浏览器知道将结果呈现为HTML。 &lt;html&gt;&lt;h1&gt;hello world&lt;/h1&gt;&lt;/html&gt; 我们将在API的输出中详细讲解。 3.2 路由和输入 传入的HTTP请求必须“路由”到一个或多个R函数。Plumber有两个不同的函数系列：端点和过滤器。 通常，当请求到达Plumber路由器时，Plumber首先将该请求通过其过滤器。一旦所有过滤器处理了请求，路由器将查找可满足传入请求的端点。如果找到一个，它将调用端点并使用端点返回的值响应传入的请求。如果没有端点与请求匹配，则将404 Not Found返回错误（其行为可由set404Handler方法控制）详见自定义路由。 3.2.1 端点 此批注指定此函数负责生成对任何GET请求的响应/hello。从函数返回的值将用作对请求的响应（在通过序列化程序运行以将响应转换为JSON之后）。在这种情况下，GET响应/hello将返回[“hello world”]带有的内容JSON Content-Type。 生成端点的注释包括： @get @post @put @delete @head 请注意，单个端点可以支持多个动词。下面的函数将被用来处理任何传入的GET，POST或PUT请求/cars #&#39; @get /cars #&#39; @post /cars #&#39; @put /cars function(){ ... } 3.2.2 过滤器 过滤器可用于定义用于处理传入请求的“管道”。这允许API作者将复杂的逻辑分解为一系列独立的，可理解的步骤。与端点不同，请求可以在生成响应之前通过多个Plumber过滤器。 通常，Plumber路由器会在尝试查找满足请求的端点之前，通过所有已定义的过滤器传递请求。 过滤器可以在处理请求时执行以下三种操作之一： 可能在改变请求之后将控制转发到下一个处理程序。 返回响应本身而不是转发给后续处理程序 抛出一个错误 3.2.2.1 转发给另一个处理程序 过滤器最常见的行为是在改变传入请求或调用某些外部副作用后将请求传递给下一个处理程序。一个常见的用例是使用过滤器作为请求记录器： #* Log some information about the incoming request #* @filter logger function(req){ cat(as.character(Sys.time()), &quot;-&quot;, req$REQUEST_METHOD, req$PATH_INFO, &quot;-&quot;, req$HTTP_USER_AGENT, &quot;@&quot;, req$REMOTE_ADDR, &quot;\\n&quot;) plumber::forward() } 此过滤器是直接的：它调用外部操作（日志记录），然后调用forward()将控制权传递给管道中的下一个处理程序（另一个过滤器或端点） 类似的过滤器可能会改变它给出的请求或响应对象上的某些状态 #* @filter setuser function(req){ un &lt;- req$cookies$user # Make req$username available to endpoints req$username &lt;- un plumber::forward() } 3.2.2.2 返回响应 过滤器也可以返回响应。您可能希望检查请求是否满足某些约束（如身份验证），并且 - 在某些情况下 - 返回响应而不调用任何其他处理程序。例如，可以使用过滤器来检查用户是否已经过身份验证。 #* @filter checkAuth function(req, res){ if (is.null(req$username)){ res$status &lt;- 401 # Unauthorized return(list(error=&quot;Authentication required&quot;)) } else { plumber::forward() } } Plumber API中出现错误的常见原因是忘记forward()在过滤器中调用。在这样的过滤器中，最后一行的结果将作为对传入请求的响应以静默方式返回。这可能会导致您的API表现出非常奇怪的行为，具体取决于返回的内容。当您使用过滤器时，请务必仔细审核所有代码路径，以确保您正在调用forward()，导致错误或故意返回值。 3.2.2.3 抛出错误 最后，过滤器可能会抛出错误。如果在定义过滤器的代码中出错或者过滤器故意调用stop()以触发错误，则会发生这种情况。在这种情况下，任何后续处理程序都不会处理请求，并且会立即将其发送到路由器的错误处理程序。有关如何自定义此错误处理程序的详细信息，请参阅路由器自定义。 3.2.3 动态路由 除了具有类似硬编码的路由之外/hello，Plumber端点还可以具有动态路由。动态路由允许端点定义一组更灵活的路径，以便它们匹配。 users &lt;- data.frame( uid=c(12,13), username=c(&quot;kim&quot;, &quot;john&quot;) ) #&#39; Lookup a user #&#39; @get /users/&lt;id&gt; function(id){ subset(users, uid==id) } 此API使用动态路径/users/来匹配任何形式的请求，/users/后跟一些路径元素，如数字或字母。在这种情况下，如果找到具有相关ID的用户，则返回有关用户的信息，否则返回空对象。 此API使用动态路径/users/来匹配任何形式的请求，/users/后跟一些路径元素，如数字或字母。在这种情况下，如果找到具有相关ID的用户，则返回有关用户的信息，否则返回空对象。 您可以根据需要命名这些动态路径元素，但请注意，动态路径中使用的名称必须与函数的参数名称匹配（在本例中为两者id）。 您甚至可以执行更复杂的动态路由，例如： #&#39; @get /user/&lt;from&gt;/connect/&lt;to&gt; function(from, to){ # Do something with the `from` and `to` variables... } 除非另有说明，否则从查询字符串或动态路径传递到管道工端点的所有参数都将是字符串。例如，请考虑以下API。 #&#39; @get /type/&lt;id&gt; function(id){ list( id = id, type = typeof(id) ) } 访问http：// localhost：8000 / types / 14将返回： { &quot;id&quot;: [&quot;14&quot;], &quot;type&quot;: [&quot;character&quot;] } 如果您只打算支持动态路由中特定参数的特定数据类型，则可以在路径本身中指定所需的类型。 #* @get /user/&lt;id:int&gt; function(id){ next &lt;- id + 1 # ... } #* @post /user/activated/&lt;active:bool&gt; function(active){ if (!active){ # ... } } 下面详细介绍了可以在动态类型中使用的类型名称的映射以及它们如何映射到R数据类型。 3.2.3.1 静态文件处理 plumber包括一个静态文件服务器，可用于托管静态资源（如JavaScript，CSS或HTML文件）的目录。这些服务器配置相当简单，并且可以集成到plumber应用程序中。 #* @assets ./files/static list() 此示例将在服务器./files/static的默认/public路径中公开本地目录。因此，如果您有一个文件./files/static/branding.html，它将在您的plumber服务器上可用/public/branding.html。 您可以选择提供其他参数来配置用于服务器的公共路径。例如 #* @assets ./files/static /static list() 请求的目录不在/public，但在/static 在上面的示例中，服务器的“实现”只是一个空的list()。还可以指定function()与其他plumber注释类似的操作。此时，实现不会改变静态服务器的行为。最终，此列表或函数可以通过更改缓存控制设置等内容来提供配置服务器的机会。 3.2.3.2 输入处理 根据传入HTTP请求的路径和方法路由请求，但请求可以包含比此更多的信息。它们可能包含其他HTTP标头，查询字符串或请求正文。所有这些字段都可以被视为您的Plumber API的“输入”。 这个可以详细的参考plumber的官方文档，在此不再赘述。 3.3 Rendering Output 3.3.1 序列化器 默认情况下，Plumber通过jsonliteR包将对象序列化为JSON 。但是，包中内置了各种其他序列化程序。 3.3.2 绕过序列化 在某些情况下，可能需要直接从R返回值而不进行序列化。您可以通过从端点返回响应对象来绕过序列化。例如，请考虑以下API #&#39; Endpoint that bypasses serialization #&#39; @get / function(res){ res$body &lt;- &quot;Literal text here!&quot; res } 从此端点返回的响应将包含Literal text here!没有Content-Type标头且没有任何其他序列化的主体。 同样，您可以利用@serializer contentType不对响应进行序列化但指定contentType标头的注释。如果希望更好地控制发送的响应，可以使用此批注。 #* @serializer contentType list(type=&quot;application/pdf&quot;) #* @get /pdf function(){ tmp &lt;- tempfile() pdf(tmp) plot(1:10, type=&quot;b&quot;) text(4, 8, &quot;PDF from plumber!&quot;) text(6, 2, paste(&quot;The time is&quot;, Sys.time())) dev.off() readBin(tmp, &quot;raw&quot;, n=file.info(tmp)$size) } 运行此API并访问http://localhost:8000/pdf将下载从R生成的PDF（如果您的客户支持，则本机显示PDF） 3.3.3 boxed and unboxed JSON 您可能已经注意到，从Plumber生成的API响应将奇异值（或“标量”）呈现为数组。例如： jsonlite::toJSON(list(a=5)) ## {&quot;a&quot;:[5]} a元素的值虽然是单数，但仍然呈现为数组。这可能会让您感到惊讶，但这样做是为了保持输出的一致性。虽然JSON将标量与矢量对象区分开来，但R却没有。这在将R对象序列化为JSON时会产生歧义，因为不清楚特定元素是应该呈现为原子值还是JSON数组。 考虑以下API，它以字典方式返回比给定字母“更高”的所有字母。 #&#39; Get letters after a given letter #&#39; @get /boxed function(letter=&quot;A&quot;){ LETTERS[LETTERS &gt; letter] } #&#39; Get letters after a given letter #&#39; @serializer unboxedJSON #&#39; @get /unboxed function(letter=&quot;A&quot;){ LETTERS[LETTERS &gt; letter] } 访问http：// localhost：8000 / boxed？letter = U或http：// localhost：8000 / unboxed？letter = U将返回相同的响应 [&quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;] 但是，http：// localhost：8000 / boxed？letter = Y将产生： [&quot;Z&quot;] 而http：// localhost：8000 / unboxed？letter = Y将产生： &quot;Z&quot; Plumber继承了jsonlite::toJSON设置的默认值，auto_unbox=FALSE这将导致所有长度为1的向量仍然呈现为JSON数组。unboxedJSON如果要更改特定端点的此行为，可以将端点配置为使用序列化程序（如上所示） 3.3.4 自定义图像序列化程序 @jpeg和@png分别返回到客户端jpeg()或png()功能。这些功能接受各种各样的定制包括输出额外的选项width，height以及bg等等 #&#39; Example of customizing graphical output #&#39; @png (width = 400, height = 500) #&#39; @get / function(){ plot(1:10) } 3.3.5 错误处理 Plumber包装每个端点调用，以便它可以正常捕获错误。 #&#39; Example of throwing an error #&#39; @get /simple function(){ stop(&quot;I&#39;m an error!&quot;) # 状态代码为500 } #&#39; Generate a friendly error #&#39; @get /friendly function(res){ msg &lt;- &quot;Your request did not include a required parameter.&quot; res$status &lt;- 400 # Bad request list(error=jsonlite::unbox(msg)) } 3.3.6 设置Cookies(*) 作为完成请求的一部分，Plumber API可以选择在客户端上设置HTTP cookie。HTTP API不会隐式包含“会话”的概念。如果没有一些附加信息，Plumber无法确定进来的两个HTTP请求是否与同一用户相关联。Cookie提供了一种方法来委托客户端代表您存储某些状态，以便所选数据可以比单个HTTP请求更长时间; 这里讨论使用cookie跟踪API中的状态的全部含义。 3.3.6.1 设置未加密的Cookie 下面的API端点将返回一个随机字母，但它会记住您是否喜欢大写或小写字母的首选项。 #&#39; @put /preferences function(res, capital){ if (missing(capital)){ stop(&quot;You must specify a value for the &#39;capital&#39; preference.&quot;) } res$setCookie(&quot;capitalize&quot;, capital) } #&#39; @get /letter function(req) { capitalize &lt;- req$cookies$capitalize # Default to lower-case unless user preference is capitalized alphabet &lt;- letters # The capitalize cookie will initially be empty (NULL) if (!is.null(capitalize) &amp;&amp; capitalize == &quot;1&quot;){ alphabet &lt;- LETTERS } list( letter = sample(alphabet, 1) ) } 由于此API使用PUT请求来测试此API，因此我们将curl在命令行上使用它来测试它。（没有任何关于需要PUT请求的cookie ;您可以轻松地修改此API以使用GET请求。）我们可以从访问/letter端点开始，我们将看到API默认为小写字母。curl http://localhost:8000/letter { &quot;letter&quot;: [&quot;y&quot;] } 如果我们发送PUT请求并指定capital参数，则将在客户端上设置cookie，以允许服务器在将来的请求中容纳我们的首选项。在curl，您需要使用该-c选项指定要在其中保存这些cookie的文件。这是一个很好的提醒，客户端处理cookie的方式不同 - 有些人根本不会支持它们 - 所以如果你想使用它们，请确保你打算用API支持的客户端很好地使用cookie。 要发送PUT请求，将参数设置capital为1，我们可以调用：curl -c cookies.txt -X PUT –data ‘capital=1’ “http://localhost:8000/preferences”。如果您打印出该cookies.txt文件，您现在应该看到它包含一个名为capitalize值的cookie 1。 我们可以提出另一个GET请求，/letter看它是否符合我们的偏好。但是我们需要告诉curl我们使用-b交换机发送此请求时使用我们刚刚创建的cookie文件：curl -b cookies.txt http://localhost:8000/letter。您现在应该看到API返回一个随机的大写字母。 3.3.6.2 设置加密的cookie 除了存储纯文本cookie之外，Plumber还支持处理加密的cookie,加密的cookie会阻止用户查看其中存储的内容，并对其内容进行签名，以便用户无法修改存储的内容。 要使用此功能，必须在构建路由器后将其明确添加到路由器中。例如，您可以运行以下命令序列来创建支持加密会话cookie的路由器。 pr &lt;- plumb(&quot;myfile.R&quot;) pr$registerHooks(sessionCookie(&quot;mySecretHere&quot;, &quot;cookieName&quot;)) pr$run() 你会注意到上面的例子正在使用sessionCookiePlumber附带的钩子。通过在路由器上添加注册这些挂钩，您将确保该req$session对象在传入请求中可用，并且cookieName在响应准备好发送给用户时持久保存到命名的cookie 。在这个例子中，用于加密数据的密钥“mySecretHere”显然是一个非常弱的密钥。 与之不同的是res$setHeader()，附加的值req$session 是通过序列化的jsonlite; 这样您就可以自由地在会话中使用更复杂的数据结构，例如列表。与此不同的是res$setHeaders()，req$session使用您提供的密钥作为sessionCookie()函数的第一个参数来加密数据。 例如，我们将存储一个加密的cookie，用于计算此客户端访问特定端点的次数： #* @get /sessionCounter function(req){ count &lt;- 0 if (!is.null(req$session$counter)){ count &lt;- as.numeric(req$session$counter) } req$session$counter &lt;- count + 1 return(paste0(&quot;This is visit #&quot;, count)) } 同样，sessionCookie()在此代码工作之前，您需要在路由器上注册挂钩。 如果您检查浏览器中设置的cookie，您会发现它的值在到达客户端时已加密。但是当它到达Plumber时，您的cookie可以作为常规R列表使用，并且可以被读取或修改。 3.4 部署 不要使用run()方法，部署自己的API,这样是很危险的！对于plumber的生产环境的部署有如下方式： DigitalOcean，RStudio Connect，Docker， pm2。在这里我们着重介绍plumber API部署在Docker和pm2, 我们将举一个具体的时机例子并测试我们生产环境的部署效果。 3.4.1 Docker（基础） 在此不会深入研究Docker的细节或如何在系统上设置或安装所有内容。Docker 为那些希望入门的人提供了一些很好的资源。在这里，我们假设您已安装Docker，并且您熟悉启动容器所需的基本命令。 安装镜像 docker pull trestletech/plumber #查看现在系统中存在的镜像 docker images # 后边会常用的docker命令 docker pull ** docker ps # 查看正在运行的容器列表 docker stop IDs docker rmi IDs docker rm XXX 运行服务 docker run --rm -p 8000:8000 trestletech/plumber \\ /usr/local/lib/R/site-library/plumber/examples/04-mean-sum/plumber.R docker run 告诉Docker运行一个新容器 --rm 告诉Docker在容器完成后进行清理 -p 8000:8000 说将端口8000从plumber容器（我们将运行服务器的位置）映射到本地计算机的端口8000 trestletech/plumber 是我们要运行的镜像的名称 /usr/local/lib/R/site-library/plumber/examples/03-mean-sum/plumber.R是Docker容器内部到您要托管的Plumber文件的路径。 docker run --rm -p 8000:8000 -v `pwd`/api.R:/plumber.R trestletech/plumber /plumber.R -v 把当前工作目录下的api.R 挂载到镜像中的/plumber.R的目录下 定义了该文件的位置应为/plumber.R，所以我们最后给出的参数告诉容器在哪里查找plumber定义 3.4.2 Docker（高级） 关于多plumber部署，同一端口的多应用部署，负载均衡，可以参考https://www.rplumber.io/docs/hosting.html#custom-dockerfiles 3.4.3 pm2 不熟悉在Docker中托管API ，那么您需要找到一种运行方式，直接管理服务器上的Plumber API。 pm2是一个最初以Node.js为目标的流程管理器。这里我们将展示在Ubuntu 14.04中执行此操作所需的命令，但您可以使用pm2支持的任何操作系统或分发。最后，您将拥有一台服务器，可在启动时自动启动plumber服务，如果它们崩溃则重新启动它们，甚至可以集中管理管道服务的日志。 3.4.3.1 安装pm2 现在您已准备好安装pm2。pm2是npm（Node.js的包管理系统）中维护的包; 它还需要Node.js才能运行。所以要开始你要安装Node.js. 在Ubuntu 14.04上，必要的命令是： sudo apt-get update sudo apt-get install nodejs npm # 由于Ubuntu下已经有一个名叫node的库，因此Node.js在ubuntu下默认叫nodejs，需要额外处理一下 sudo ln -s /usr/bin/nodejs /usr/bin/node 一旦安装了npm和Node.js，就可以安装pm2了。 sudo npm install -g pm2 这将-g在您的服务器上安装pm2 global（），这意味着您现在应该能够运行pm2 –version并获取已安装的pm2的版本号。 为了让pm2在启动时启动你的服务，你应该运行sudo pm2 startup它将为你的系统创建必要的文件，以便在你启动你的机器时运行pm2。 3.4.3.2 Wrap Your Plumber File 将Plumber文件部署到服务器后，您仍需要告诉服务器如何运行服务器。你可能习惯于运行像这样的命令 pr &lt;- plumb(&quot;myfile.R&quot;) pr$run(port=4500) 不幸的是，pm2本身并不理解R脚本; 您可以使用该pm2 list命令查看pm2已在运行的服务。如果您现在运行此命令，您将看到pm2没有任何它负责的服务。将脚本和代码存储在所需目录中后，使用以下命令告知pm2您的服务。 pm2 start --interpreter=&quot;Rscript&quot; /usr/local/plumber/myfile/run-myfile.R 您应该看到有关pm2的一些输出，它们启动了您的服务实例，然后是pm2的一些状态信息。如果一切正常，您将看到您的新服务已注册并正在运行。您可以通过pm2 list再次执行来查看相同的输出。 一旦您对已定义的pm2服务感到满意，您可以使用pm2 save告诉pm2保留下次启动计算机时运行的服务集。您定义的所有服务都将自动重新启动。 如果要查看更多信息，使用pm2 show run-myfile 如果您需要检查服务的日志文件，则可以运行pm2 logs run-myfile 如果您想要查看服务器和所有pm2服务的运行状况的大图，您可以运行pm2 monit它将显示所有服务的RAM和CPU使用情况的仪表板。 3.4.4 XGBoost模型预测部署实例 我们将给予XGBoost模型，通过一个具体的实例演示从模型的训练到部署的整个过程，这里我们分别采用docker和pm2部署我们的模型 1.模型的训练与预测 # 垃圾邮件分类，一共57个特征 library(xgboost) library(glmnet) library(ElemStatLearn) x = as.matrix(spam[, -ncol(spam)]) y = as.numeric(spam$spam) - 1 xgbmodel = xgboost(data = x, label = y, nrounds = 5, objective = &#39;binary:logistic&#39;) # 这里模型保存的路径可以自己设置 save(xgbmodel, file=&quot;xgb.rda&quot;) # glmmodel = cv.glmnet(x = x, y = y, family = &#39;binomial&#39;) # save(glmmodel, file=&quot;glm.rda&quot;) # 模型加载 xgb_model &lt;- load(&quot;xgb_model/xgb.rda&quot;) xgbmodel # 模型预测 data_spam &lt;- as.matrix(spam[1, -ncol(spam)]) pred &lt;- predict(xgbmodel,data_spam) pred &lt;- xgboost:::predict.xgb.Booster(object = xgbmodel, newdata = data_spam) 2.构建plumber API接口 #* Logging #* @filter logger function(req){ model &lt;&lt;- load(&quot;/home/R_code/xgb_model/xgb.rda&quot;) cat(as.character(Sys.time()), &quot;-&quot;, req$REQUEST_METHOD, req$PATH_INFO, &quot;-&quot;, req$HTTP_USER_AGENT, &quot;@&quot;, req$REMOTE_ADDR,&quot;\\n&quot;) plumber::forward() } # xgb_api #* XGBoost predict model #* @param id The row id of Spam data. #* @serializer unboxedJSON #* @get /predict function(id){ if(as.integer(id) &lt;= 4601){ data_spam &lt;- as.matrix(spam[as.integer(id), -ncol(spam)]) pred &lt;- predict(xgbmodel,data_spam) # pred &lt;- xgboost:::predict.xgb.Booster(object = xgbmodel, newdata = data_spam) list(spam_id = id, predict = pred) } else{ stop(&#39;Your id error&#39;) } } #* static source #* @assets /home/R_code/xgb_model/static /home list() 3.在R中启用服务 library(xgboost) library(ElemStatLearn) library(plumber) setwd(&#39;/home/R_code/xgb_model&#39;) pr &lt;- plumb(&#39;xgb_api.R&#39;) pr$run(host=&#39;0.0.0.0&#39;,port=8088) 4.Docker中部署 docker run --rm -p 8000:8000 -v `pwd`/xgb_model_docker:/xgb_model_docker trestletech/plumber /xgb_model_docker/xgb_api.R 但是此时我们使用的像xgboost这样的包并没有加载到镜像中，解决这个问题的方法是我们自己自定义dockerfiles。关于这方面的内容你可以参考docker的相关教程。 5.pm2部署 pm2 start --interpreter=&quot;Rscript&quot; /home/R_code/xgb_model/test_api.R 6.效果展示 3.5 其他 3.5.1 环境 当你plumb()是一个文件时，Plumber会调用source()该文件来评估你定义的任何顶级代码。 # Global code; gets executed at plumb() time. counter &lt;- 0 #&#39; @get / function(){ # Only gets evaluated when this endpoint is requested. counter &lt;&lt;- counter + 1 } counter则将创建变量，该变量将存在于为此API创建的环境中,每访问一次counter就加1，此技术允许所有端点和过滤器共享在API顶层定义的某些数据。 默认情况下，每个路由和子路由都会创建自己的环境，如果要共享环境，则在创建路由器时需要提供单个共享环境。关于环境的介绍可以参考我的R语言面向对象的编程。 3.5.2 文件系统 写入文件过程中的并发性是不可靠的，举个简单的例子,如果您已经将API水平扩展到五个R进程，那么两个转到write.csv()同时，你会看到一个进程的数据被另一个进程立即覆盖，或者 - 更糟糕的是 - 你可能最终得到一个无法读取的损坏的CSV文件。不要依赖文件系统来协调并发运行的单个R进程的共享状态。还有就是要注意，有些平台可能不具备磁盘持久化。 协调API状态时要考虑的最后一个选项是利用外部数据存储。这可以是关系数据库（如MySQL），非关系数据库（如MongoDB），也可以是Redis等事务数据存储。 任何这些选项的一个重要考虑因素是确保它们是“事务性的”，这意味着两个试图同时写入的Plumber进程不会相互覆盖。如果你对此感兴趣，可在https://db.rstudio.com/看一些的的介绍 如果在终止Plumber流程时有一个需要清理的数据库连接池。您可以使用exit钩子来定义这样的处理程序 pr &lt;- plumb(&quot;plumber.R&quot;) pr$registerHook(&quot;exit&quot;, function(){ print(&quot;Bye bye!&quot;) }) pr$run() 当您中断API时（例如，通过Escape按键或Ctrl+C），您将看到Bye bye!打印到控制台。您甚至可以注册多个exit挂钩，它们将按照注册顺序运行。 3.5.3 API的安全性 3.5.3.1 网络和防火墙 防火墙是一种阻止不受欢迎的网络流量的方法。大多数台式计算机和许多服务器都带有开箱即用的防火墙。这意味着如果要公开在端口8000上运行的API，则需要将防火墙配置为接受该端口上的传入连接。防火墙也可以在其他网络中介上配置，因此您可能需要配置多个防火墙以允许流量通过，以便向API客户端公开所需的端口。 3.5.3.2 拒绝服务（DoS） 使用拒绝服务（DoS）攻击是为了通过流量压缩服务器或服务来暂时关闭服务器或服务。DoS场景可能是由单个无知用户无意中发出可能要求服务器执行某项不可能完成任务的请求引起的，或者可能是由恶意行为者故意引入，利用大量机器重复发出昂贵的请求。服务器响应。 在设计Plumber API时，应该采用一些做法，以便围绕API请求可能发起的工作提供安全保护。 #&#39; This is an example of an UNSAFE endpoint which #&#39; is vulnerable to a DOS attack. #&#39; @get / #&#39; @png function(pts=10) { # An example of an UNSAFE endpoint. plot(1:pts) } #&#39; This is an example of an safe endpoint which #&#39; checks user input to avoid a DOS attack #&#39; @get / #&#39; @png function(pts=10) { if (pts &gt; 1000){ stop(&quot;pts must be &lt; 1,000&quot;) } plot(1:pts) } 在这里，可以看到我们只允许用户请求最多1,000个点的图表。超过该限制的任何请求将立即终止，无需进一步计算。 还有其他的，比如限制文件读取，跨站请求伪造等，可以详细参考一些前端的知识，如果你只是在企业内部内网环境中构建接口，可暂时不考虑这些内容。 3.5.4 创建和控制路由器 要以编程方式实例化新的Plumber路由器，您可以调用plumber$new()。这将返回一个没有端点的空白Plumber路由器。您可以调用run()返回的对象来启动API，但它不知道如何响应任何请求，因此任何传入流量都会得到404响应。 3.5.5 定义端点 可以使用该handle()方法在路由器上定义端点。例如，要定义响应GET请求/和POST请求的Plumber API /submit，您可以使用以下代码： pr &lt;- plumber$new() pr$handle(&quot;GET&quot;, &quot;/&quot;, function(req, res){ # ... }) pr$handle(&quot;POST&quot;, &quot;/submit&quot;, function(req, res){ # ... }) 如果使用注释来定义API，则在这些handle调用中定义的“处理程序”函数与您在plumber.R文件中定义的代码相同。 该handle()方法采用其他参数，允许您控制端点的细微差别行为，例如它可能抢占哪个过滤器或应该使用哪个序列化程序。例如，以下端点将使用Plumber的HTML序列化程序。 pr &lt;- plumber$new() pr$handle(&quot;GET&quot;, &quot;/&quot;, function(){ &quot;&lt;html&gt;&lt;h1&gt;Programmatic Plumber!&lt;/h1&gt;&lt;/html&gt;&quot; }, serializer=plumber::serializer_html()) 3.5.6 定义过滤器 使用filter()Plumber路由器的方法定义新的过滤器： pr &lt;- plumber$new() pr$filter(&quot;myFilter&quot;, function(req){ req$filtered &lt;- TRUE forward() }) pr$handle(&quot;GET&quot;, &quot;/&quot;, function(req){ paste(&quot;Am I filtered?&quot;, req$filtered) }) 3.5.7 在路由器上注册钩子(*) plumber路由器支持“钩子”的概念，可以注册这些钩子以在请求的生命周期中的特定点执行某些代码。Plumber路由器目前支持四个钩子： preroute(data, req, res) postroute(data, req, res, value) preserialize(data, req, res, value) postserialize(data, req, res, value) 在上述所有情况中，您可以访问data参数中的一次性环境，该参数作为每个请求的临时数据存储创建。钩子可以在这些钩子中存储临时数据，这些钩子可以被处理同一请求的其他钩子重用。 在Plumber路由器中定义钩子时的一个特性是能够修改返回的值。这种钩子的约定是：任何接受命名参数的函数value都应该返回新值。这可能是传入的值的未修改版本，也可能是变异值。但在任何一种情况下，如果你的钩子接受一个参数value，那么你的钩子返回的任何东西都将被用作响应的新值。 您可以使用该registerHook方法添加钩子，也可以使用registerHooks带有名称列表的方法一次添加多个钩子，其中名称是钩子的名称，值是处理程序本身。 pr &lt;- plumber$new() pr$registerHook(&quot;preroute&quot;, function(req){ cat(&quot;Routing a request for&quot;, req$PATH_INFO, &quot;...\\n&quot;) }) pr$registerHooks(list( preserialize=function(req, value){ print(&quot;About to serialize this value:&quot;) print(value) # Must return the value since we took one in. Here we&#39;re not choosing # to mutate it, but we could. value }, postserialize=function(res){ print(&quot;We serialized the value as:&quot;) print(res$body) } )) pr$handle(&quot;GET&quot;, &quot;/&quot;, function(){ 123 }) 发出GET请求/将从我们注册的三个事件中打印出各种信息。 3.5.8 Mounting &amp; Static File Routers（*） plumber路由器可以通过使用mount()方法通过路径划分API，这是将大型API分解为较小文件的绝佳技术。 root &lt;- plumber$new() users &lt;- plumber$new(&quot;users.R&quot;) root$mount(&quot;/users&quot;, users) products &lt;- plumber$new(&quot;products.R&quot;) root$mount(&quot;/products&quot;, products) 这与用于定义提供静态文件目录的路由器的方法相同。静态文件路由器只是使用创建的Plumber路由器的一个特例PlumberStatic$new()。例如 pr &lt;- plumber$new() stat &lt;- PlumberStatic$new(&quot;./myfiles&quot;) pr$mount(&quot;/assets&quot;, stat) 这将使存储在./myfiles目录中的文件和目录在API的/assets/路径下可用。 3.5.9 自定义路由器 还可以使用以下任何一种方法修改路由器的行为： setSerializer() - 设置路由器的默认序列化程序。 setErrorHandler() - 设置在任何过滤器或端点生成错误时调用的错误处理程序。 set404Handler() - 设置在任何过滤器，端点或子路由器无法提供传入请求时调用的处理程序。 3.5.10 调试 3.5.10.1 打印调试 大多数程序员首先通过在代码中添加print语句来进行调试，以便在某些时候检查状态。在R中，print()或者cat()可以用来打印出一些状态。例如，cat(“i is currently:”, i)可以在代码中插入，以帮助您确保变量i是代码中该位置的变量。 这种方法在Plumber同样可行。在交互式环境中开发Plumber API时，此调试输出将记录到您调用run()API 的同一终端。在非交互式生产环境中，这些消息将包含在API服务器日志中以供以后检查。 3.5.10.2 交互式调试 在本地开发API时通过browser()在其中一个过滤器或端点中添加调用，然后在客户端中访问API来利用。当您想要检查多个不同的变量或与函数内部的当前状态进行交互时，这提供了一种强大的技术。 #&#39; @get / function(req, res){ browser() list(a=123) } "],
["jug.html", "第 4 章 jug 4.1 What is jug? 4.2 Install and Hello World 4.3 Middleware（中间件） 4.4 预定义的中间件 4.5 事件监听 4.6 预定义的事件侦听器 4.7 请求，响应和错误对象 4.8 URL调度 4.9 启动jug实例 4.10 线性回归模型的API举栗 4.11 官方栗子", " 第 4 章 jug 4.1 What is jug? jug是一个微型的轻量级的框架，基于httpuv包，为的是部署你的R代码更简单。 jug不会是一个高效的框架，它的作用是让你轻松的为你的R代码创建API, jug的简单灵活，理论上你可以用其构建一个更一般的Web应用。 4.2 Install and Hello World 要安装最新版本，请使用devtools： devtools::install_github(&quot;Bart6114/jug&quot;) # jug.parallel允许jug并行处理请求 devtools :: install_github（“Bart6114/jug.parallel”） 或者安装CRAN版本： install.packags(&quot;jug&quot;) 加载库： library(jug) library(jug.parallel) # Example1 jug() # Example2 library(jug) jug() %&gt;% get(&quot;/&quot;, function(req, res, err){ &quot;Hello World!&quot; }) %&gt;% simple_error_handler_json() %&gt;% serve_it() # Example3 library(jug) jug() %&gt;% get(&quot;/&quot;, function(req, res, err){ &quot;Hello World!&quot; }) %&gt;% simple_error_handler_json() %&gt;% serve_it_parallel(processes=8) kill_servers() jug与magrittr（%&gt;%）的管道功能密切配合。 4.3 Middleware（中间件） 在中间件方面，jug有遵循中间件的规范Express。在jug中，中间件是一个可以访问request（req），response（res）和error（err）对象的函数。 可以定义多个中间件。中间件的添加顺序很重要。请求将从添加的第一个中间件（更具体地说是在其中指定的函数 - 请参见下一段）开始。它将继续通过添加的中间件传递,直到中间件不返回NULL。 4.3.1 方法不敏感的中间件 该use函数是一个方法不敏感的中间件说明符。虽然它对方法不敏感，但它可以绑定到特定路径。如果path参数（接受带grepl设置的正则表达式字符串perl=TRUE)如果设置为NULL，它也会变得路径不敏感，并将处理每个请求。 路径不敏感的栗子： jug() %&gt;% use(path = NULL, function(req, res, err){ &quot;test 1,2,3!&quot; }) %&gt;% serve_it() $ curl 127.0.0.1:8080/xyz test 1,2,3! 同样的栗子，但是路径敏感: jug() %&gt;% use(path = &quot;/&quot;, function(req, res, err){ &quot;test 1,2,3!&quot; }) %&gt;% serve_it() $ curl 127.0.0.1:8080/xyz curl: (52) Empty reply from server $ curl 127.0.0.1:8080 test 1,2,3! 请注意，在上面的示例中，缺少错误/缺少路由处理（服务器可能崩溃/不响应），稍后将详细介绍. 4.3.2 方法敏感的中间件 与请求方法不敏感的中间件相同的样式，有可用的请求方法敏感中间件。更具体地讲，您可以使用get，post，put和delete功能。 此类中间件使用path参数绑定到路径。如果path设置为NULL，它将绑定到路径的每个请求，对应相应的请求方法。 jug() %&gt;% get(path = &quot;/&quot;, function(req, res, err){ &quot;get test 1,2,3!&quot; }) %&gt;% serve_it() $ curl 127.0.0.1:8080 get test 1,2,3! 中间件意味着被链接，因此要将不同的功能绑定到不同的路径： jug() %&gt;% get(path = &quot;/&quot;, function(req, res, err){ &quot;get test 1,2,3 on path /&quot; }) %&gt;% get(path = &quot;/my_path&quot;, function(req, res, err){ &quot;get test 1,2,3 on path /my_path&quot; }) %&gt;% serve_it() $ curl 127.0.0.1:8080 get test 1,2,3 on path / $ curl 127.0.0.1:8080/my_path get test 1,2,3 on path /my_path 4.3.3 Websocket协议 默认情况下，所有中间件便利功能都绑定到http协议。但是，您可以使用websocket中间件功能通过websocket访问jug服务器ws。下面是回传传入消息的示例。 jug() %&gt;% ws(&quot;/echo_message&quot;, function(binary, message, res, err){ message }) %&gt;% serve_it() 打开连接并向ws://127.0.0.1:8080/echo_message其发送例如消息test将返回该值test。 请注意，websocket支持在此阶段是实验性的，尽量不使用jug操作websocket 4.3.4 include定义其他位置的中间件 为了使代码更加模块化，您可以将其他定义的中间件链包含到您的jug实例中。为此，您可以使用collector()和include()功能的组合。 下面是一个collector本地定义（在相同的R脚本中）和include栗子: collected_mw&lt;- collector() %&gt;% get(&quot;/&quot;, function(req,res,err){ return(&quot;test&quot;) }) res&lt;-jug() %&gt;% include(collected_mw) %&gt;% serve_it() 然而，也有可能include一个collector是在另一个.R文件中定义。 让我们说下面是文件my_middlewares.R： library(jug) collected_mw&lt;- collector() %&gt;% get(&quot;/&quot;, function(req,res,err){ return(&quot;test2&quot;) }) 我们可以include如下： res&lt;-jug() %&gt;% include(collected_mw, &quot;my_middlewares.R&quot;) %&gt;% serve_it() 4.4 预定义的中间件 4.4.1 错误处理 一个简单的错误处理中间件（simple_error_handler/ simple_error_handler_json），它捕获未绑定的路径和func评估错误。如果您没有实现自定义错误处理程序，我建议您将其中任何一个添加到您的jug实例中。simple_error_handler返回一个HTML错误页面而simple_error_handler_json返回一个JSON消息。 jug() %&gt;% simple_error_handler() %&gt;% serve_it() $ curl 127.0.0.1:8080 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Not found&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;No handler bound to path&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 如果要实现自己的自定义错误处理，只需查看这些简单错误处理中间件的代码即可。 请注意，通常您希望在指定所有其他中间件后将错误处理程序中间件附加到jug实例。 4.4.2 轻松使用自己的函数 创建jug的主要原因是可以轻松访问您自己的自定义R函数。功能decorate专门为此目的而构建。如果decorate您自己的函数，它会将请求的查询字符串中传递的所有参数转换为函数的参数。它还将所有头文件作为参数传递给函数。如果您的函数不接受...参数，则会删除函数未明确请求的所有查询/标头参数。如果您的功能请求req，res或err参数（或…）相应的对象将被传递。 say_hello&lt;-function(name){paste(&quot;hello&quot;,name,&quot;!&quot;)} jug() %&gt;% get(&quot;/&quot;, decorate(say_hello)) %&gt;% serve_it() 如果在上面，您通过name查询字符串或GET请求中的标头传递参数，它将返回如下例所示。 $ curl 127.0.0.1:8080/?name=Bart hello Bart ! 4.4.3 静态文件服务器 serve_static_file中间件可以提供静态文件。 jug() %&gt;% serve_static_files() %&gt;% serve_it() 默认根目录是返回的目录，setwd()可以通过向中间件提供root_path参数来指定serve_static_files. 除了开发之外，我不建议使用jug来提供静态文件。 4.4.4 CORS功能(*) CORS功能(跨源资源共享)由cors()中间件功能引入。 请考虑以下示例。 jug() %&gt;% cors() %&gt;% get(&quot;/&quot;, function(req, res, err){ &quot;Hello World!&quot; }) %&gt;% serve_it() $ curl -v 127.0.0.1:8080/ * Trying 127.0.0.1... * Connected to 127.0.0.1 (127.0.0.1) port 8080 (#0) &gt; GET / HTTP/1.1 &gt; Host: 127.0.0.1:8080 &gt; User-Agent: curl/7.43.0 &gt; Accept: */* &gt; &lt; HTTP/1.1 200 OK &lt; Content-Type: text/html &lt; Access-Control-Allow-Origin: * &lt; Access-Control-Allow-Methods: POST,GET,PUT,OPTIONS,DELETE,PATCH &lt; Content-Length: 12 &lt; * Connection #0 to host 127.0.0.1 left intact 如您所见，这会添加一些默认的CORS标头。查看?cors配置选项，请注意您还可以通过指定path参数将CORS标头添加到特定路径。 4.4.5 认证 目前，只有通过中间件功能内置支持基本身份验证https://www.httpwatch.com/httpgallery/authentication/ auth_basic,间件将检查有效用户名/密码组合的请求。如果传递了无效组合，它将返回401状态，WWW-Authenticate标题和文本正文，指出存在身份验证错误。 首先，您需要定义一个接受username和password参数的函数。TRUE如果组合有效且FALSE组合无效，则应返回功能。一个虚拟的例子如下所示。注意，此功能还可以检查例如数据库以验证组合。 # dummy account checker account_checker &lt;- function(username, password){ # do something to verify the username and password and return TRUE if combination OK all(username == &quot;test_user&quot;, password == &quot;test_password&quot;) } 接下来，您需要auth_basic在中间件链中实例化中间件。该auth_basic函数接受用户名/密码验证功能作为第一个参数。下面给出两个例子。第一个显示如何对特定路径（/test）进行身份验证。 jug() %&gt;% get(&quot;/&quot;, function(req, res, err){ &quot;/ req&quot; }) %&gt;% get(&quot;/test&quot;, auth_basic(account_checker), function(req, res, err){ &quot;/test req&quot; }) %&gt;% serve_it() 下面的第二个示例显示了如何为jug实例中的所有路径激活基本身份验证。 jug() %&gt;% use(NULL, auth_basic(account_checker)) %&gt;% get(&quot;/&quot;, function(req, res, err){ &quot;/ req&quot; }) %&gt;% serve_it() 4.5 事件监听 从版本0.1.7.902开始，事件监听的概念已经可用。由于中间件不足以实现强大的Logger，因此引入了事件和事件监听的概念。目前，侦听器可以绑定到事件，下面给出一个示例： jug() %&gt;% get(&quot;/&quot;, function(req,res,err){&quot;foo&quot;}) %&gt;% on(&quot;finish&quot;, function(req, res, err){ print(&quot;the finish event was received; request processing finished!&quot;)} ) %&gt;% serve_it() 目前有三项活动： start：一旦收到新请求，就会触发此事件 finish：一旦请求完全处理，就会触发此事件 error：一旦在中间件内引发错误，就会触发此事件 start和finish事件将传递的当前状态req，res以及err对象。error事件将传递第四个参数，即错误消息的字符表示。 4.6 预定义的事件侦听器 4.6.1 Logger futile.logger jug() %&gt;% get(&quot;/&quot;, function(req,res,err){&quot;foo&quot;}) %&gt;% get(&quot;/err&quot;, function(req,res,err){stop(&quot;bar&quot;)}) %&gt;% logger(threshold = futile.logger::DEBUG, log_file=&#39;logfile.log&#39;, console=TRUE) %&gt;% simple_error_handler_json() %&gt;% serve_it() 在上面的示例中，Logger阈值设置futile.logger::DEBUG为我们将在执行期间接收详细信息,在这个例子中，Logger将写入logfile.log 和将输出到控制台.有关Logger阈值的更多信息，请查看该futile.logger包的文档。 4.7 请求，响应和错误对象 4.7.1 Request（req）对象 该req对象包含请求规范。它有不同的属性： req$params 由查询字符串，JSON正文，URL参数或多部分表单传递的参数的命名列表 req$path 请求路径 req$method 请求方法 req$raw 传递的原始请求对象 httpuv req$body 完整的请求正文作为字符串 req$protocol无论是http或websocket req$headers 请求中的标头的命名列表（作为小写并从HTTP_底层httpuv框架提供的前缀中剥离） 它附带以下功能： req$get_header(key)返回与请求中指定键关联的值（无需担心HTTP_前缀） req$set_header(key, value) 允许在处理请求时设置/更改标头（对于将数据传递到下一个中间件可能很有用） req$attach(key, value) 将变量附加到 req$params 4.7.2 Response（res）对象 该res对象包含响应规范。它有不同的属性： res$headers 一个命名的标题列表 res$status 响应的状态（默认为200） res$body响应的主体（自动设置为不NULL返回的中间件的内容或通过诸如此类的方法res$json()） 它还有一组功能： res$set_header(key, value) 设置自定义标头 res$content_type(type) 设置自己的内容类型（MIME） res$set_status(status) 设置响应的状态 res$text(body) 明确地设定反应的主体 res$json(obj, auto_unbox=TRUE) 将对象转换为JSON，将其设置为正文并设置正确的内容类型 res$plot(plot_obj, base64=TRUE) 方便函数将绘图对象作为响应体返回，返回的绘图可以是图像的base64表示（默认）或实际的二进制数据 4.7.3 Error（err）对象 该err对象包含可通过的错误列表err$errrors。您可以通过调用将错误添加到此列表中err$set(error)。错误将转换为字符。有关更多详细信息，请参阅“错误处理”。 4.8 URL调度 在路径参数get，post，…功能被处理为正则表达式模式。 如果路径定义中有命名的捕获组，则它们将附加到该req$params对象。例如，模式/test/(?&lt;id&gt;.*)/(?&lt;id2&gt;.*)将导致变量id和id2（及其各自的值）绑定到req$params对象。 如果路径模式未以字符串^正则表达式标记的开头启动或以字符串标记的结尾结束$，则将分别在路径模式规范的开头和结尾处明确地插入这些模式。例如，路径模式/将转换为^/$ 4.9 启动jug实例 只需serve_it()在管道链的末端调用（参见Install and Hello World ！示例） 4.10 线性回归模型的API举栗 训练mtcars数据集上的线性回归模型，并假设我们的目标是mpg根据输入gear和预测每加仑英里或变量hp。 head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 mpg_model &lt;- lm(mpg~gear+hp, data=mtcars) summary(mpg_model) ## ## Call: ## lm(formula = mpg ~ gear + hp, data = mtcars) ## ## Residuals: ## Min 1Q Median 3Q Max ## -4.7977 -2.4288 -0.7685 2.2405 7.5943 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 17.755144 3.241809 5.477 6.74e-06 *** ## gear 3.176520 0.762584 4.165 0.000255 *** ## hp -0.063931 0.008206 -7.791 1.36e-08 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 3.108 on 29 degrees of freedom ## Multiple R-squared: 0.7513, Adjusted R-squared: 0.7341 ## F-statistic: 43.79 on 2 and 29 DF, p-value: 1.731e-09 建立一个最小预测函数。 predict_mpg &lt;- function(gear, hp){ predict(mpg_model, newdata = data.frame(gear=as.numeric(gear), hp=as.numeric(hp)))[[1]] } 我们可以通过提供gear和hp参数来测试函数。 predict_mpg(gear = 4, hp = 80) ## [1] 25.34671 现在，要将此函数公开为Web API，我们需要构建一个jug实例。我们可以使用内置的decorate中间件来简化predict_mpg功能的集成。下面是一个最小的例子。 jug() %&gt;% post(&quot;/predict-mpg&quot;, decorate(predict_mpg)) %&gt;% simple_error_handler_json() %&gt;% serve_it() 我们现在可以向http://127.0.0.1:8080/predict-mpgURL 发送http POST请求，它将返回预测值！它开箱即用，带有JSON主体中的参数，multipart/form-data或者作为一个x-www-form-urlencoded。 JSON正文 curl -X POST \\ http://127.0.0.1:8080/predict-mpg \\ -H &#39;content-type: application/json&#39; \\ -d &#39;{&quot;hp&quot;: 80, &quot;gear&quot;: 4}&#39; 多部分形式 curl -X POST \\ http://127.0.0.1:8080/predict-mpg \\ -H &#39;content-type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW&#39; \\ -F hp=80 \\ -F gear=4 urlencode表单 curl -X POST \\ http://127.0.0.1:8080/predict-mpg \\ -H &#39;content-type: application/x-www-form-urlencoded&#39; \\ -d &#39;gear=4&amp;hp=80&#39; 4.11 官方栗子 https://github.com/Bart6114/jug-crud-example "],
["fiery.html", "第 5 章 fiery", " 第 5 章 fiery "],
["rserve.html", "第 6 章 Rserve", " 第 6 章 Rserve "],
["restrserve.html", "第 7 章 RestRserve", " 第 7 章 RestRserve "],
["mailr.html", "第 8 章 mailR", " 第 8 章 mailR mailR是一个比较小的包，主要解决的问题是R与邮件发送的问题,该包就一个方法：send.mail() 方法调用方式为： send.mail(from, to, subject = &quot;&quot;, body = &quot;&quot;, encoding = &quot;iso-8859-1&quot;, html = FALSE, inline = FALSE, smtp = list(), authenticate = FALSE, send = TRUE, attach.files = NULL, debug = FALSE, ...) 参数列表： from 有效的发送者的邮箱 to 目标接收的邮箱 subject 邮箱主题 body 邮件体 encoding 邮件内容字符编码 支持包括 iso-8859-1 (default), utf-8, us-ascii, and koi8-r html bool值，是否把邮箱体解析成html inline 布尔值，HTML文件中的图像是否应该嵌入内联。 smtp lsit类型，链接邮箱的smtp authenticate 一个布尔变量，用于指示是否需要授权连接到 SMTP服务器。如果设置为true，请参阅SMTP参数所需参数的详细信息。 发送一个布尔值，指示电子邮件是否应该在函数的末尾发送。 （默认行为）。如果设置为false，函数将电子邮件对象返回给父 环境。 attach.files 链接到文件的文件系统中路径的字符向量或有效 URL到附加到电子邮件（详见更多信息附加URL） debug bool值，是否查看debug的真实细节 … Optional arguments to be passed related to file attachments. See details for more Example1: mailR::send.mail( from = &#39;sender@tuandai.com&#39;, # 发送人 to = &#39;sendee@tuandai.com&#39;, # 接收人 cc = &#39;carboncopy@tuandai.com&#39;, # 抄送人 subject = &#39;邮件标题&#39;, body = as.character( &#39;&lt;div style = &quot;color:red&quot;&gt;邮件正文，可以为HTML格式&lt;/div&gt;&#39; ), attach.files = NULL, # 附件的路径 encoding = &quot;utf-8&quot;, smtp = list( host.name = &#39;smtp.exmail.qq.com&#39;, # 邮件服务器IP地址 port = 465, # 邮件服务器端口 user.name = &#39;senderName&#39;, # 发送人名称 passwd = &#39;yourpassword&#39;, # 密码 ssl = T), html = T, inline = T, authenticate = T, send = T, debug = F ) Example2: send.mail(from = &quot;sender@gmail.com&quot;, to = c(&quot;Recipient 1 &lt;recipient1@gmail.com&gt;&quot;, &quot;recipient2@gmail.com&quot;), cc = c(&quot;CC Recipient &lt;cc.recipient@gmail.com&gt;&quot;), bcc = c(&quot;BCC Recipient &lt;bcc.recipient@gmail.com&gt;&quot;), subject=&quot;Subject of the email&quot;, body = &quot;Body of the email&quot;, smtp = list(host.name = &quot;aspmx.l.google.com&quot;, port = 25), authenticate = FALSE, send = TRUE) Example3: send.mail(from = &quot;sender@gmail.com&quot;, to = c(&quot;recipient1@gmail.com&quot;, &quot;recipient2@gmail.com&quot;), subject = &quot;Subject of the email&quot;, body = &quot;Body of the email&quot;, smtp = list(host.name = &quot;smtp.gmail.com&quot;, port = 465, user.name = &quot;gmail_username&quot;, passwd = &quot;password&quot;, ssl = TRUE), authenticate = TRUE, send = TRUE) Example4: email &lt;- send.mail(from = &quot;Sender Name &lt;sender@gmail.com&gt;&quot;, to = &quot;recipient@gmail.com&quot;, subject = &quot;A quote from Gandhi&quot;, body = &quot;In Hindi : थोडा सा अभ्यास बहुत सारे उपदेशों से बेहतर है। English translation: An ounce of practice is worth more than tons of preaching.&quot;, encoding = &quot;utf-8&quot;, smtp = list(host.name = &quot;smtp.gmail.com&quot;, port = 465, user.name = &quot;gmail_username&quot;, passwd = &quot;password&quot;, ssl = T), authenticate = TRUE, send = TRUE) Example5: send.mail(from = &quot;sender@gmail.com&quot;, to = c(&quot;recipient1@gmail.com&quot;, &quot;recipient2@gmail.com&quot;), subject = &quot;Subject of the email&quot;, body = &quot;Body of the email&quot;, smtp = list(host.name = &quot;smtp.gmail.com&quot;, port = 465, user.name = &quot;gmail_username&quot;, passwd = &quot;password&quot;, ssl = TRUE), authenticate = TRUE, send = TRUE, attach.files = c(&quot;./download.log&quot;, &quot;upload.log&quot;), file.names = c(&quot;Download log&quot;, &quot;Upload log&quot;), # optional parameter file.descriptions = c(&quot;Description for download log&quot;, &quot;Description for upload log&quot;)) Example6: send.mail(from = &quot;sender@gmail.com&quot;, to = c(&quot;recipient1@gmail.com&quot;, &quot;recipient2@gmail.com&quot;), subject = &quot;Subject of the email&quot;, body = &quot;&lt;html&gt;The apache logo - &lt;img src=\\&quot;http://www.apache.org/images/asf_logo_wide.gif\\&quot;&gt;&lt;/html&gt;&quot;, # can also point to local file (see next example) html = TRUE, smtp = list(host.name = &quot;smtp.gmail.com&quot;, port = 465, user.name = &quot;gmail_username&quot;, passwd = &quot;password&quot;, ssl = TRUE), authenticate = TRUE, send = TRUE) Example7: send.mail(from = &quot;sender@gmail.com&quot;, to = c(&quot;recipient1@gmail.com&quot;, &quot;recipient2@gmail.com&quot;), subject = &quot;Subject of the email&quot;, body = &quot;path.to.local.html.file&quot;, html = TRUE, inline = TRUE, smtp = list(host.name = &quot;smtp.gmail.com&quot;, port = 465, user.name = &quot;gmail_username&quot;, passwd = &quot;password&quot;, ssl = TRUE), authenticate = TRUE, send = TRUE) "],
["rweixin.html", "第 9 章 Rweixin(*)", " 第 9 章 Rweixin(*) 关于RWeixin，这里不做介绍，可以参考: https://github.com/Lchiffon/Rweixin https://dataxujing.github.io/assets/bowen20/slide_langdawei.pdf "],
["reference.html", "第 10 章 参考文献 10.1 opencpu 10.2 plumber 10.3 jug", " 第 10 章 参考文献 10.1 opencpu opencpu API文档 The opencpu Systerm 利用 R 和 opencpu 搭建高可用的 HTTP 服务—刘思喆 R 语言实战之模型部署 10.2 plumber plumber官方教程 R工程化—Rest API 之plumber包 10.3 jug jug官方教程 "]
]
