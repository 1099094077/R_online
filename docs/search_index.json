[
["index.html", "R语言模型部署实战 序言", " R语言模型部署实战 徐静 2018-08-06 序言 我们的模型不能只停留在线下的分析报告中，训练好的R模型如何应用到生产环境？目前针对于R语言的模型生产环境应用的方式有很多，比如用其他语言去调用，Java，Python等语言均可方便的调用R脚本；生成PMML文件，目前R中主流的一些R模型均支持PMML比如xgboost,lightGBM等，其他语言不需要调用R脚本只需调用统一的PMML文件就可以；还有就是Web端的部署，比如可以做成REST API供其他语言调用，或直接做成web应用供其他用户访问，本书主要针对于R语言模型的Web端的部署。过程中，我们会先后介绍httpuv,opencpu,plumber, jug,fiery,Rserve,RestRserve,等一些和模型线上化部署相关的R包(当然shiny也可以，但他不是我们本书的重点)，最后会介绍mailR和Rweixin两个R和邮件与微信通信的R包，用于线上化部署的监测。当然会有其他的线上化部署方式。 欢迎进入R模型线上化部署的海洋！ "],
["e585b3e4ba8ee68891.html", "关于我", " 关于我 徐静： 硕士研究生, 目前的研究兴趣主要包括：数理统计，统计机器学习，深度学习，网络爬虫，前端可视化，R语言和Python语言的超级粉丝，多个R包和Python模块的作者，现在正逐步向Java迁移。 Graduate students,the current research interests include: mathematical statistics, statistical machine learning, deep learning, web crawler, front-end visualization. He is a super fan of R and Python, and the author of several R packages and Python modules, and now gradually migrating to Java. "],
["httpuv.html", "第 1 章 httpuv 1.1 方法介绍 1.2 例子演示", " 第 1 章 httpuv 在httpuv的官网中,有这么一段描述： Allows R code to listen for and interact with HTTP and WebSocket clients, so you can serve web traffic directly out of your R process. Implementation is based on libuv and http-parser. This is a low-level library that provides little more than network I/O and implementations of the HTTP and WebSocket protocols. For an easy way to create web applications, try Shiny instead. 我们可以通过httpuv搭建一个访问R模型的web API,但可能这不是最好的。 本部分我们首先介绍官方提供的一些方法，然后解析官方提供的演示Demo,从而达到熟练使用httpuv的目的。 1.1 方法介绍 下面我们解析一下httpuv官方提供的一些调用方法，并演示一些调用方法对应的实例 1.使用URI编码/解码以与Web浏览器相同的方式对字符串进行编码/解码。 encodeURI(value) encodeURIComponent(value) decodeURI(value) decodeURIComponent(value) 参数列表 value 用于编码和解码的字符向量，UTF-8字符编码 library(httpuv) value &lt;- &quot;https://baidu.com/中国;?/&quot; encodeURI(value) ## [1] &quot;https://baidu.com/%D6%D0%B9%FA;?/&quot; encodeURIComponent(value) ## [1] &quot;https%3A%2F%2Fbaidu.com%2F%D6%D0%B9%FA%3B%3F%2F&quot; decodeURI(value) ## [1] &quot;https://baidu.com/中国;?/&quot; decodeURIComponent(value) ## [1] &quot;https://baidu.com/中国;?/&quot; 注意： encodeURI 与 encodeURIComponent是不一样的因为前者不对特殊字符: ;,/?:@&amp;=+$等进行encode 2.中断httpuv运行的环路 interrupt() 检查ip地址的类型是ipv4还是ipv6 ipFamily(ip) 参数列表 ip 一个代表IP地址的字符串 返回值的意义：如果是IPv4返回4，如果是IPv6返回6，如果不是IP地址返回-1 ipFamily(&quot;127.0.0.1&quot;) # 4 ## [1] 4 ipFamily(&quot;500.0.0.500&quot;) # -1 ## [1] -1 ipFamily(&quot;500.0.0.500&quot;) # -1 ## [1] -1 ipFamily(&quot;::&quot;) # 6 ## [1] 6 ipFamily(&quot;::1&quot;) # 6 ## [1] 6 ipFamily(&quot;fe80::1ff:fe23:4567:890a&quot;) # 6 ## [1] 6 3.将原始向量转换为BASE64编码字符串 rawToBase64(x) 参数列表 x 原始向量 set.seed(100) result &lt;- rawToBase64(as.raw(runif(19, min=0, max=256))) #stopifnot(identical(result, &quot;TkGNDnd7z16LK5/hR2bDqzRbXA==&quot;)) result ## [1] &quot;TkGNDnd7z16LK5/hR2bDqzRbXA==&quot; 4.运行一个server runServer(host, port, app, interruptIntervalMs = NULL) 参数列表 host IPv4地址, 或是“0.0.0.0”监听所有的IP port 端口号 app 一个定义应用的函数集合 interruptIntervalMs 该参数不提倡使用，1.3.5版本后废除 app &lt;- list(call = function(req){ list(status=200L, headers = list( &#39;Content-Type&#39; = &#39;text/html&#39; ), body = &quot;HelloWorld!&quot;) }) runServer(&quot;0.0.0.0&quot;, 5000,app) 5.过程请求 处理HTTP请求和WebSocket消息。 如果R的调用堆栈上没有任何东西，如果R是 在命令提示符下闲置，不必调用此函数，因为请求将 自动处理。但是，如果R正在执行代码，则请求将不被处理。 要么调用栈是空的，要么调用这个函数(或者，调用run_now())。 service(timeoutMs = ifelse(interactive(), 100, 1000)) 参数列表 timeoutMs 返回之前运行的毫秒数。 6.创建HTTP/WebSocket后台服务器（弃用） startDaemonizedServer(host, port, app) 7.创建HTTP/WebSocket服务器 startServer(host, port, app) startPipeServer(name, mask, app) 参数列表 host ip地址 port 端口号 app 一个定义应用的函数集 app &lt;- list( call = function(req) { list( status = 200L, headers = list( &#39;Content-Type&#39; = &#39;text/html&#39; ), body = &quot;Hello world!&quot; ) } ) handle &lt;- startServer(&quot;0.0.0.0&quot;, 5000,app) # 此服务器的句柄，可以传递给StestServer以关闭服务器。 stopServer(handle) 8.停止所有应用 stopAllServers() 9.在UNIX环境中停止运行的后台服务器（弃用） stopDaemonizedServer(handle) 10.停止一个服务 stopServer(handle) 1.2 例子演示 json-server # Connect to this using websockets on port 9454 # Client sends to server in the format of {&quot;data&quot;:[1,2,3]} # The websocket server returns the standard deviation of the sent array library(jsonlite) library(httpuv) # Server app &lt;- list( onWSOpen = function(ws) { ws$onMessage(function(binary, message) { # Decodes message from client message &lt;- fromJSON(message) # Sends message to client ws$send( # JSON encode the message toJSON( # Returns standard deviation for message sd(message$data) ) ) }) } ) runServer(&quot;0.0.0.0&quot;, 9454, app, 250) 2.echo library(httpuv) app &lt;- list( call = function(req) { wsUrl = paste(sep=&#39;&#39;, &#39;&quot;&#39;, &quot;ws://&quot;, ifelse(is.null(req$HTTP_HOST), req$SERVER_NAME, req$HTTP_HOST), &#39;&quot;&#39;) list( status = 200L, headers = list( &#39;Content-Type&#39; = &#39;text/html&#39; ), body = paste( sep = &quot;\\r\\n&quot;, &quot;&lt;!DOCTYPE html&gt;&quot;, &quot;&lt;html&gt;&quot;, &quot;&lt;head&gt;&quot;, &#39;&lt;style type=&quot;text/css&quot;&gt;&#39;, &#39;body { font-family: Helvetica; }&#39;, &#39;pre { margin: 0 }&#39;, &#39;&lt;/style&gt;&#39;, &quot;&lt;script&gt;&quot;, sprintf(&quot;var ws = new WebSocket(%s);&quot;, wsUrl), &quot;ws.onmessage = function(msg) {&quot;, &#39; var msgDiv = document.createElement(&quot;pre&quot;);&#39;, &#39; msgDiv.innerHTML = msg.data.replace(/&amp;/g, &quot;&amp;amp;&quot;).replace(/\\\\&lt;/g, &quot;&amp;lt;&quot;);&#39;, &#39; document.getElementById(&quot;output&quot;).appendChild(msgDiv);&#39;, &quot;}&quot;, &quot;function sendInput() {&quot;, &quot; var input = document.getElementById(&#39;input&#39;);&quot;, &quot; ws.send(input.value);&quot;, &quot; input.value = &#39;&#39;;&quot;, &quot;}&quot;, &quot;&lt;/script&gt;&quot;, &quot;&lt;/head&gt;&quot;, &quot;&lt;body&gt;&quot;, &#39;&lt;h3&gt;Send Message&lt;/h3&gt;&#39;, &#39;&lt;form action=&quot;&quot; onsubmit=&quot;sendInput(); return false&quot;&gt;&#39;, &#39;&lt;input type=&quot;text&quot; id=&quot;input&quot;/&gt;&#39;, &#39;&lt;h3&gt;Received&lt;/h3&gt;&#39;, &#39;&lt;div id=&quot;output&quot;/&gt;&#39;, &#39;&lt;/form&gt;&#39;, &quot;&lt;/body&gt;&quot;, &quot;&lt;/html&gt;&quot; ) ) }, onWSOpen = function(ws) { ws$onMessage(function(binary, message) { ws$send(message) }) } ) browseURL(&quot;http://localhost:9454/&quot;) runServer(&quot;0.0.0.0&quot;, 9454, app, 250) 3.deamon-echo library(httpuv) .lastMessage &lt;- NULL app &lt;- list( call = function(req) { wsUrl = paste(sep=&#39;&#39;, &#39;&quot;&#39;, &quot;ws://&quot;, ifelse(is.null(req$HTTP_HOST), req$SERVER_NAME, req$HTTP_HOST), &#39;&quot;&#39;) list( status = 200L, headers = list( &#39;Content-Type&#39; = &#39;text/html&#39; ), body = paste( sep = &quot;\\r\\n&quot;, &quot;&lt;!DOCTYPE html&gt;&quot;, &quot;&lt;html&gt;&quot;, &quot;&lt;head&gt;&quot;, &#39;&lt;style type=&quot;text/css&quot;&gt;&#39;, &#39;body { font-family: Helvetica; }&#39;, &#39;pre { margin: 0 }&#39;, &#39;&lt;/style&gt;&#39;, &quot;&lt;script&gt;&quot;, sprintf(&quot;var ws = new WebSocket(%s);&quot;, wsUrl), &quot;ws.onmessage = function(msg) {&quot;, &#39; var msgDiv = document.createElement(&quot;pre&quot;);&#39;, &#39; msgDiv.innerHTML = msg.data.replace(/&amp;/g, &quot;&amp;amp;&quot;).replace(/\\\\&lt;/g, &quot;&amp;lt;&quot;);&#39;, &#39; document.getElementById(&quot;output&quot;).appendChild(msgDiv);&#39;, &quot;}&quot;, &quot;function sendInput() {&quot;, &quot; var input = document.getElementById(&#39;input&#39;);&quot;, &quot; ws.send(input.value);&quot;, &quot; input.value = &#39;&#39;;&quot;, &quot;}&quot;, &quot;&lt;/script&gt;&quot;, &quot;&lt;/head&gt;&quot;, &quot;&lt;body&gt;&quot;, &#39;&lt;h3&gt;Send Message&lt;/h3&gt;&#39;, &#39;&lt;form action=&quot;&quot; onsubmit=&quot;sendInput(); return false&quot;&gt;&#39;, &#39;&lt;input type=&quot;text&quot; id=&quot;input&quot;/&gt;&#39;, &#39;&lt;h3&gt;Received&lt;/h3&gt;&#39;, &#39;&lt;div id=&quot;output&quot;/&gt;&#39;, &#39;&lt;/form&gt;&#39;, &quot;&lt;/body&gt;&quot;, &quot;&lt;/html&gt;&quot; ) ) }, onWSOpen = function(ws) { ws$onMessage(function(binary, message) { .lastMessage &lt;&lt;- message ws$send(message) }) } ) server &lt;- startDaemonizedServer(&quot;0.0.0.0&quot;, 9454, app) # check the value of .lastMessage after echoing to check it is being updated # call this after done #stopDaemonizedServer(server) library(httpuv) app = list(call = function(req){ # 获取POST的参数 postdata = req$rook.input$read_lines() qs = httr:::parse_query(gsub(&quot;^\\\\?&quot;, &quot;&quot;, postdata)) dat = jsonlite::fromJSON(qs$jsonDat) print(dat) # 计算返回结果 r = 0.3 + 0.1 * dat$v1 - 0.2 * dat$v2 + 0.1 * dat$v3 output = jsonlite::toJSON(list(message = &#39;suceess&#39;, result = r), auto_unbox = T) res = list(status = 200L, headers = list(&#39;Content-Type&#39; = &#39;application/json&#39;), body = output) return(res) }) # 启动服务 server = startServer(&quot;0.0.0.0&quot;, 1124L, app = app) while(TRUE) { service() Sys.sleep(0.001) } # stopServer(server) RCurl::postForm(&#39;127.0.0.1:1124&#39;, style = &#39;post&#39;, .params = list(jsonDat = &#39;{&quot;v1&quot;:1,&quot;v2&quot;:2,&quot;v3&quot;:3}&#39;) ) httpuv是相对比较底层的包，熟练使用需要掌握前端知识，并且需要用到RCurl，httr相关爬虫包的一些知识去处理。本人不推荐这种方式进行模型的部署。 "],
["opencpu.html", "第 2 章 opencpu", " 第 2 章 opencpu "],
["plumber.html", "第 3 章 plumber", " 第 3 章 plumber "],
["jug.html", "第 4 章 jug", " 第 4 章 jug "],
["fiery.html", "第 5 章 fiery", " 第 5 章 fiery "],
["rserve.html", "第 6 章 Rserve", " 第 6 章 Rserve "],
["restrserve.html", "第 7 章 RestRserve", " 第 7 章 RestRserve "],
["mailr.html", "第 8 章 mailR", " 第 8 章 mailR mailR是一个比较小的包，主要解决的问题是R与邮件发送的问题,该包就一个方法：send.mail() 方法调用方式为： send.mail(from, to, subject = &quot;&quot;, body = &quot;&quot;, encoding = &quot;iso-8859-1&quot;, html = FALSE, inline = FALSE, smtp = list(), authenticate = FALSE, send = TRUE, attach.files = NULL, debug = FALSE, ...) 参数列表： from 有效的发送者的邮箱 to 目标接收的邮箱 subject 邮箱主题 body 邮件体 encoding 邮件内容字符编码 支持包括 iso-8859-1 (default), utf-8, us-ascii, and koi8-r html bool值，是否把邮箱体解析成html inline 布尔值，HTML文件中的图像是否应该嵌入内联。 smtp lsit类型，链接邮箱的smtp authenticate 一个布尔变量，用于指示是否需要授权连接到 SMTP服务器。如果设置为true，请参阅SMTP参数所需参数的详细信息。 发送一个布尔值，指示电子邮件是否应该在函数的末尾发送。 （默认行为）。如果设置为false，函数将电子邮件对象返回给父 环境。 attach.files 链接到文件的文件系统中路径的字符向量或有效 URL到附加到电子邮件（详见更多信息附加URL） debug bool值，是否查看debug的真实细节 … Optional arguments to be passed related to file attachments. See details for more Example1: mailR::send.mail( from = &#39;sender@tuandai.com&#39;, # 发送人 to = &#39;sendee@tuandai.com&#39;, # 接收人 cc = &#39;carboncopy@tuandai.com&#39;, # 抄送人 subject = &#39;邮件标题&#39;, body = as.character( &#39;&lt;div style = &quot;color:red&quot;&gt;邮件正文，可以为HTML格式&lt;/div&gt;&#39; ), attach.files = NULL, # 附件的路径 encoding = &quot;utf-8&quot;, smtp = list( host.name = &#39;smtp.exmail.qq.com&#39;, # 邮件服务器IP地址 port = 465, # 邮件服务器端口 user.name = &#39;senderName&#39;, # 发送人名称 passwd = &#39;yourpassword&#39;, # 密码 ssl = T), html = T, inline = T, authenticate = T, send = T, debug = F ) Example2: send.mail(from = &quot;sender@gmail.com&quot;, to = c(&quot;Recipient 1 &lt;recipient1@gmail.com&gt;&quot;, &quot;recipient2@gmail.com&quot;), cc = c(&quot;CC Recipient &lt;cc.recipient@gmail.com&gt;&quot;), bcc = c(&quot;BCC Recipient &lt;bcc.recipient@gmail.com&gt;&quot;), subject=&quot;Subject of the email&quot;, body = &quot;Body of the email&quot;, smtp = list(host.name = &quot;aspmx.l.google.com&quot;, port = 25), authenticate = FALSE, send = TRUE) Example3: send.mail(from = &quot;sender@gmail.com&quot;, to = c(&quot;recipient1@gmail.com&quot;, &quot;recipient2@gmail.com&quot;), subject = &quot;Subject of the email&quot;, body = &quot;Body of the email&quot;, smtp = list(host.name = &quot;smtp.gmail.com&quot;, port = 465, user.name = &quot;gmail_username&quot;, passwd = &quot;password&quot;, ssl = TRUE), authenticate = TRUE, send = TRUE) Example4: email &lt;- send.mail(from = &quot;Sender Name &lt;sender@gmail.com&gt;&quot;, to = &quot;recipient@gmail.com&quot;, subject = &quot;A quote from Gandhi&quot;, body = &quot;In Hindi : थोडा सा अभ्यास बहुत सारे उपदेशों से बेहतर है। English translation: An ounce of practice is worth more than tons of preaching.&quot;, encoding = &quot;utf-8&quot;, smtp = list(host.name = &quot;smtp.gmail.com&quot;, port = 465, user.name = &quot;gmail_username&quot;, passwd = &quot;password&quot;, ssl = T), authenticate = TRUE, send = TRUE) Example5: send.mail(from = &quot;sender@gmail.com&quot;, to = c(&quot;recipient1@gmail.com&quot;, &quot;recipient2@gmail.com&quot;), subject = &quot;Subject of the email&quot;, body = &quot;Body of the email&quot;, smtp = list(host.name = &quot;smtp.gmail.com&quot;, port = 465, user.name = &quot;gmail_username&quot;, passwd = &quot;password&quot;, ssl = TRUE), authenticate = TRUE, send = TRUE, attach.files = c(&quot;./download.log&quot;, &quot;upload.log&quot;), file.names = c(&quot;Download log&quot;, &quot;Upload log&quot;), # optional parameter file.descriptions = c(&quot;Description for download log&quot;, &quot;Description for upload log&quot;)) Example6: send.mail(from = &quot;sender@gmail.com&quot;, to = c(&quot;recipient1@gmail.com&quot;, &quot;recipient2@gmail.com&quot;), subject = &quot;Subject of the email&quot;, body = &quot;&lt;html&gt;The apache logo - &lt;img src=\\&quot;http://www.apache.org/images/asf_logo_wide.gif\\&quot;&gt;&lt;/html&gt;&quot;, # can also point to local file (see next example) html = TRUE, smtp = list(host.name = &quot;smtp.gmail.com&quot;, port = 465, user.name = &quot;gmail_username&quot;, passwd = &quot;password&quot;, ssl = TRUE), authenticate = TRUE, send = TRUE) Example7: send.mail(from = &quot;sender@gmail.com&quot;, to = c(&quot;recipient1@gmail.com&quot;, &quot;recipient2@gmail.com&quot;), subject = &quot;Subject of the email&quot;, body = &quot;path.to.local.html.file&quot;, html = TRUE, inline = TRUE, smtp = list(host.name = &quot;smtp.gmail.com&quot;, port = 465, user.name = &quot;gmail_username&quot;, passwd = &quot;password&quot;, ssl = TRUE), authenticate = TRUE, send = TRUE) "],
["rweixin.html", "第 9 章 Rweixin", " 第 9 章 Rweixin "],
["reference.html", "第 10 章 参考文献", " 第 10 章 参考文献 "]
]
